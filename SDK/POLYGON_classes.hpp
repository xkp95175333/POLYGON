#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: POLYGON

#include "Basic.hpp"

#include "NetCore_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "POLYGON_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "PlayFab_structs.hpp"
#include "DataContainer_structs.hpp"
#include "DeveloperSettings_classes.hpp"
#include "OnlineSubsystemUtils_classes.hpp"


namespace SDK
{

// Class POLYGON.AnimNotify_PlaySoundLocal
// 0x0018 (0x0050 - 0x0038)
class UAnimNotify_PlaySoundLocal final : public UAnimNotify
{
public:
	class USoundBase*                             Sound;                                             // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumeMultiplier;                                  // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchMultiplier;                                   // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachName;                                        // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_PlaySoundLocal">();
	}
	static class UAnimNotify_PlaySoundLocal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_PlaySoundLocal>();
	}
};
static_assert(alignof(UAnimNotify_PlaySoundLocal) == 0x000008, "Wrong alignment on UAnimNotify_PlaySoundLocal");
static_assert(sizeof(UAnimNotify_PlaySoundLocal) == 0x000050, "Wrong size on UAnimNotify_PlaySoundLocal");
static_assert(offsetof(UAnimNotify_PlaySoundLocal, Sound) == 0x000038, "Member 'UAnimNotify_PlaySoundLocal::Sound' has a wrong offset!");
static_assert(offsetof(UAnimNotify_PlaySoundLocal, VolumeMultiplier) == 0x000040, "Member 'UAnimNotify_PlaySoundLocal::VolumeMultiplier' has a wrong offset!");
static_assert(offsetof(UAnimNotify_PlaySoundLocal, PitchMultiplier) == 0x000044, "Member 'UAnimNotify_PlaySoundLocal::PitchMultiplier' has a wrong offset!");
static_assert(offsetof(UAnimNotify_PlaySoundLocal, AttachName) == 0x000048, "Member 'UAnimNotify_PlaySoundLocal::AttachName' has a wrong offset!");

// Class POLYGON.PG_PlayerState_Base
// 0x0018 (0x03C0 - 0x03A8)
class APG_PlayerState_Base : public APlayerState
{
public:
	FMulticastInlineDelegateProperty_             OnPlayerNameChanged;                               // 0x03A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UClientBackendComponent*                ClientBackendComponent;                            // 0x03B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetPlayerName(const class FString& PlayerName);
	void UpdatePlayerCombinedInfo(const TArray<EModifiedData>& ModifiedData, const class FString& CustomDelegateString);

	const struct FUniqueNetIdRepl GetUniqueNetId() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PG_PlayerState_Base">();
	}
	static class APG_PlayerState_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<APG_PlayerState_Base>();
	}
};
static_assert(alignof(APG_PlayerState_Base) == 0x000008, "Wrong alignment on APG_PlayerState_Base");
static_assert(sizeof(APG_PlayerState_Base) == 0x0003C0, "Wrong size on APG_PlayerState_Base");
static_assert(offsetof(APG_PlayerState_Base, OnPlayerNameChanged) == 0x0003A8, "Member 'APG_PlayerState_Base::OnPlayerNameChanged' has a wrong offset!");
static_assert(offsetof(APG_PlayerState_Base, ClientBackendComponent) == 0x0003B8, "Member 'APG_PlayerState_Base::ClientBackendComponent' has a wrong offset!");

// Class POLYGON.BallisticMaterialResponseMap
// 0x0050 (0x0080 - 0x0030)
class UBallisticMaterialResponseMap final : public UDataAsset
{
public:
	TMap<class UPhysicalMaterial*, struct FBallisticMaterialResponseMapEntry> List;                                              // 0x0030(0x0050)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BallisticMaterialResponseMap">();
	}
	static class UBallisticMaterialResponseMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBallisticMaterialResponseMap>();
	}
};
static_assert(alignof(UBallisticMaterialResponseMap) == 0x000008, "Wrong alignment on UBallisticMaterialResponseMap");
static_assert(sizeof(UBallisticMaterialResponseMap) == 0x000080, "Wrong size on UBallisticMaterialResponseMap");
static_assert(offsetof(UBallisticMaterialResponseMap, List) == 0x000030, "Member 'UBallisticMaterialResponseMap::List' has a wrong offset!");

// Class POLYGON.PG_PlayerState_Game
// 0x0088 (0x0448 - 0x03C0)
class APG_PlayerState_Game : public APG_PlayerState_Base
{
public:
	FMulticastInlineDelegateProperty_             OnSetTeam;                                         // 0x03C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeNumberKills;                               // 0x03D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeNumberDeaths;                              // 0x03E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnVoteKick;                                        // 0x03F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C03[0x8];                                     // 0x0400(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class APG_PlayerState_Game*>           VoteKickPlayers;                                   // 0x0408(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	ETeam                                         Team;                                              // 0x0418(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         NumberKills;                                       // 0x0419(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         NumberDeaths;                                      // 0x041A(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         NumberKillsByMe;                                   // 0x041B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         NumberKillsOfMe;                                   // 0x041C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C04[0x7];                                     // 0x041D(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsAdmin;                                          // 0x0424(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsPatron;                                         // 0x0425(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C05[0x2];                                     // 0x0426(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UPlayerCoreComponent*                   PlayerCoreComponent;                               // 0x0428(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInventoryComponent_Game*               InventoryComponent;                                // 0x0430(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USquadComponent*                        SquadComponent;                                    // 0x0438(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChatSystemComponent*                   ChatSystemComponent;                               // 0x0440(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnRep_NumberDeaths();
	void OnRep_NumberKills();
	void OnRep_Team();
	void OnRep_VoteKickPlayers();
	void SetTeam(const ETeam NewTeam);

	bool CustomIsInactive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PG_PlayerState_Game">();
	}
	static class APG_PlayerState_Game* GetDefaultObj()
	{
		return GetDefaultObjImpl<APG_PlayerState_Game>();
	}
};
static_assert(alignof(APG_PlayerState_Game) == 0x000008, "Wrong alignment on APG_PlayerState_Game");
static_assert(sizeof(APG_PlayerState_Game) == 0x000448, "Wrong size on APG_PlayerState_Game");
static_assert(offsetof(APG_PlayerState_Game, OnSetTeam) == 0x0003C0, "Member 'APG_PlayerState_Game::OnSetTeam' has a wrong offset!");
static_assert(offsetof(APG_PlayerState_Game, OnChangeNumberKills) == 0x0003D0, "Member 'APG_PlayerState_Game::OnChangeNumberKills' has a wrong offset!");
static_assert(offsetof(APG_PlayerState_Game, OnChangeNumberDeaths) == 0x0003E0, "Member 'APG_PlayerState_Game::OnChangeNumberDeaths' has a wrong offset!");
static_assert(offsetof(APG_PlayerState_Game, OnVoteKick) == 0x0003F0, "Member 'APG_PlayerState_Game::OnVoteKick' has a wrong offset!");
static_assert(offsetof(APG_PlayerState_Game, VoteKickPlayers) == 0x000408, "Member 'APG_PlayerState_Game::VoteKickPlayers' has a wrong offset!");
static_assert(offsetof(APG_PlayerState_Game, Team) == 0x000418, "Member 'APG_PlayerState_Game::Team' has a wrong offset!");
static_assert(offsetof(APG_PlayerState_Game, NumberKills) == 0x000419, "Member 'APG_PlayerState_Game::NumberKills' has a wrong offset!");
static_assert(offsetof(APG_PlayerState_Game, NumberDeaths) == 0x00041A, "Member 'APG_PlayerState_Game::NumberDeaths' has a wrong offset!");
static_assert(offsetof(APG_PlayerState_Game, NumberKillsByMe) == 0x00041B, "Member 'APG_PlayerState_Game::NumberKillsByMe' has a wrong offset!");
static_assert(offsetof(APG_PlayerState_Game, NumberKillsOfMe) == 0x00041C, "Member 'APG_PlayerState_Game::NumberKillsOfMe' has a wrong offset!");
static_assert(offsetof(APG_PlayerState_Game, bIsAdmin) == 0x000424, "Member 'APG_PlayerState_Game::bIsAdmin' has a wrong offset!");
static_assert(offsetof(APG_PlayerState_Game, bIsPatron) == 0x000425, "Member 'APG_PlayerState_Game::bIsPatron' has a wrong offset!");
static_assert(offsetof(APG_PlayerState_Game, PlayerCoreComponent) == 0x000428, "Member 'APG_PlayerState_Game::PlayerCoreComponent' has a wrong offset!");
static_assert(offsetof(APG_PlayerState_Game, InventoryComponent) == 0x000430, "Member 'APG_PlayerState_Game::InventoryComponent' has a wrong offset!");
static_assert(offsetof(APG_PlayerState_Game, SquadComponent) == 0x000438, "Member 'APG_PlayerState_Game::SquadComponent' has a wrong offset!");
static_assert(offsetof(APG_PlayerState_Game, ChatSystemComponent) == 0x000440, "Member 'APG_PlayerState_Game::ChatSystemComponent' has a wrong offset!");

// Class POLYGON.TraceProjectile
// 0x0210 (0x04A0 - 0x0290)
class ATraceProjectile final : public AActor
{
public:
	struct FVector                                Velocity;                                          // 0x0290(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRandomStream                          RandomStream;                                      // 0x02A8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          OwnerSafe;                                         // 0x02B0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C06[0x67];                                    // 0x02B1(0x0067)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystemComponent*               ActiveTraceComponent;                              // 0x0318(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          DebugEnabled;                                      // 0x0320(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C07[0x3];                                     // 0x0321(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DebugTrailTime;                                    // 0x0324(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DebugTrailWidth;                                   // 0x0328(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           DebugTrailColorFast;                               // 0x032C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           DebugTrailColorSlow;                               // 0x033C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          DebugPooling;                                      // 0x034C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C08[0x3];                                     // 0x034D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Wind;                                              // 0x0350(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EAtmosphereType                               AtmosphereType;                                    // 0x0368(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C09[0x3];                                     // 0x0369(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SeaLevelAirDensity;                                // 0x036C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SeaLevelSpeedOfSound;                              // 0x0370(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C0A[0x4];                                     // 0x0374(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            AirDensityCurve;                                   // 0x0378(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          SpeedOfSoundVariesWithAltitude;                    // 0x0380(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C0B[0x7];                                     // 0x0381(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            SpeedOfSoundCurve;                                 // 0x0388(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C0C[0x4];                                     // 0x0390(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SeaLevelAirPressure;                               // 0x0394(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SeaLevelAirTemperature;                            // 0x0398(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TemperatureLapseRate;                              // 0x039C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TropopauseAltitude;                                // 0x03A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SpecificGasConstant;                               // 0x03A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                WorldCenterLocation;                               // 0x03A8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          SphericalAltitude;                                 // 0x03C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C0D[0x3];                                     // 0x03C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SeaLevelRadius;                                    // 0x03C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          OverrideGravity;                                   // 0x03C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C0E[0x7];                                     // 0x03C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Gravity;                                           // 0x03D0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          SafeLaunch;                                        // 0x03E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          SafeLaunchIgnoreAttachParent;                      // 0x03E9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          SafeLaunchIgnoreAllAttached;                       // 0x03EA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C0F[0x1];                                     // 0x03EB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SafeDelay;                                         // 0x03EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         SafeLaunchIgnoredActors;                           // 0x03F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPrivate)
	float                                         MuzzleVelocityMin;                                 // 0x0400(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MuzzleVelocityMax;                                 // 0x0404(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Spread;                                            // 0x0408(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Mass;                                              // 0x040C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Diameter;                                          // 0x0410(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FormFactor;                                        // 0x0414(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            MachDragCurve;                                     // 0x0418(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         GrazingAngleExponent;                              // 0x0420(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinPenetration;                                    // 0x0424(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxPenetration;                                    // 0x0428(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PenetrationNormalization;                          // 0x042C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PenetrationNormalizationGrazing;                   // 0x0430(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PenetrationEntryAngleSpread;                       // 0x0434(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PenetrationExitAngleSpread;                        // 0x0438(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RicochetProbability;                               // 0x043C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RicochetProbabilityGrazing;                        // 0x0440(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RicochetRestitution;                               // 0x0444(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RicochetFriction;                                  // 0x0448(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RicochetSpread;                                    // 0x044C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          SpeedControlsRicochetProbability;                  // 0x0450(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          AddImpulse;                                        // 0x0451(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C10[0x2];                                     // 0x0452(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ImpulseMultiplier;                                 // 0x0454(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EPenetrationTraceType                         DefaultPenTraceType;                               // 0x0458(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C11[0x7];                                     // 0x0459(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBallisticMaterialResponseMap*          MaterialResponseMap;                               // 0x0460(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          MaterialDensityControlsPenetrationDepth;           // 0x0468(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          MaterialRestitutionControlsRicochet;               // 0x0469(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          AllowComponentCollisions;                          // 0x046A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ECollisionChannel                             TraceChannel;                                      // 0x046B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          TraceComplex;                                      // 0x046C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C12[0x3];                                     // 0x046D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CollisionMargin;                                   // 0x0470(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DespawnVelocity;                                   // 0x0474(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         IgnoredActors;                                     // 0x0478(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          DoFirstStepImmediately;                            // 0x0488(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          RandomFirstStepDelta;                              // 0x0489(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C13[0x2];                                     // 0x048A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxTracesPerStep;                                  // 0x048C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          Retrace;                                           // 0x0490(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          RetraceOnAnotherChannel;                           // 0x0491(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ECollisionChannel                             RetraceChannel;                                    // 0x0492(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          RotateActor;                                       // 0x0493(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          RotateRandomRoll;                                  // 0x0494(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          EnablePooling;                                     // 0x0495(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C14[0x2];                                     // 0x0496(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        TraceFX;                                           // 0x0498(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static void Spawn(TSubclassOf<class ATraceProjectile> bulletClass, class AItem_Gun_General* Gun, const struct FVector& SpawnLocation, const struct FVector& StartVelocity, const uint8 RandomSeed);
	static void SpawnWithExactVelocity(TSubclassOf<class ATraceProjectile> bulletClass, class AItem_Gun_General* Gun, const struct FVector& SpawnLocation, const struct FVector& StartVelocity, const uint8 RandomSeed);

	void Deactivate();
	void OnDeactivated();
	void OnImpact(bool Ricochet, bool PassedThrough, const struct FVector& ExitVelocity, const struct FVector& Impulse, float PenetrationDepth, const struct FHitResult& HitResult);
	void OnTrace(const struct FVector& StartLocation, const struct FVector& EndLocation);
	void OnTrajectoryUpdateReceived(const struct FVector& Location, const struct FVector& OldVelocity, const struct FVector& NewVelocity);

	bool CollisionFilter(const struct FHitResult& HitResult) const;
	struct FVector UpdateVelocity(const struct FVector& Location, const struct FVector& PreviousVelocity, const float DeltaTime) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TraceProjectile">();
	}
	static class ATraceProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATraceProjectile>();
	}
};
static_assert(alignof(ATraceProjectile) == 0x000008, "Wrong alignment on ATraceProjectile");
static_assert(sizeof(ATraceProjectile) == 0x0004A0, "Wrong size on ATraceProjectile");
static_assert(offsetof(ATraceProjectile, Velocity) == 0x000290, "Member 'ATraceProjectile::Velocity' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, RandomStream) == 0x0002A8, "Member 'ATraceProjectile::RandomStream' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, OwnerSafe) == 0x0002B0, "Member 'ATraceProjectile::OwnerSafe' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, ActiveTraceComponent) == 0x000318, "Member 'ATraceProjectile::ActiveTraceComponent' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, DebugEnabled) == 0x000320, "Member 'ATraceProjectile::DebugEnabled' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, DebugTrailTime) == 0x000324, "Member 'ATraceProjectile::DebugTrailTime' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, DebugTrailWidth) == 0x000328, "Member 'ATraceProjectile::DebugTrailWidth' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, DebugTrailColorFast) == 0x00032C, "Member 'ATraceProjectile::DebugTrailColorFast' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, DebugTrailColorSlow) == 0x00033C, "Member 'ATraceProjectile::DebugTrailColorSlow' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, DebugPooling) == 0x00034C, "Member 'ATraceProjectile::DebugPooling' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, Wind) == 0x000350, "Member 'ATraceProjectile::Wind' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, AtmosphereType) == 0x000368, "Member 'ATraceProjectile::AtmosphereType' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, SeaLevelAirDensity) == 0x00036C, "Member 'ATraceProjectile::SeaLevelAirDensity' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, SeaLevelSpeedOfSound) == 0x000370, "Member 'ATraceProjectile::SeaLevelSpeedOfSound' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, AirDensityCurve) == 0x000378, "Member 'ATraceProjectile::AirDensityCurve' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, SpeedOfSoundVariesWithAltitude) == 0x000380, "Member 'ATraceProjectile::SpeedOfSoundVariesWithAltitude' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, SpeedOfSoundCurve) == 0x000388, "Member 'ATraceProjectile::SpeedOfSoundCurve' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, SeaLevelAirPressure) == 0x000394, "Member 'ATraceProjectile::SeaLevelAirPressure' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, SeaLevelAirTemperature) == 0x000398, "Member 'ATraceProjectile::SeaLevelAirTemperature' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, TemperatureLapseRate) == 0x00039C, "Member 'ATraceProjectile::TemperatureLapseRate' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, TropopauseAltitude) == 0x0003A0, "Member 'ATraceProjectile::TropopauseAltitude' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, SpecificGasConstant) == 0x0003A4, "Member 'ATraceProjectile::SpecificGasConstant' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, WorldCenterLocation) == 0x0003A8, "Member 'ATraceProjectile::WorldCenterLocation' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, SphericalAltitude) == 0x0003C0, "Member 'ATraceProjectile::SphericalAltitude' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, SeaLevelRadius) == 0x0003C4, "Member 'ATraceProjectile::SeaLevelRadius' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, OverrideGravity) == 0x0003C8, "Member 'ATraceProjectile::OverrideGravity' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, Gravity) == 0x0003D0, "Member 'ATraceProjectile::Gravity' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, SafeLaunch) == 0x0003E8, "Member 'ATraceProjectile::SafeLaunch' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, SafeLaunchIgnoreAttachParent) == 0x0003E9, "Member 'ATraceProjectile::SafeLaunchIgnoreAttachParent' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, SafeLaunchIgnoreAllAttached) == 0x0003EA, "Member 'ATraceProjectile::SafeLaunchIgnoreAllAttached' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, SafeDelay) == 0x0003EC, "Member 'ATraceProjectile::SafeDelay' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, SafeLaunchIgnoredActors) == 0x0003F0, "Member 'ATraceProjectile::SafeLaunchIgnoredActors' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, MuzzleVelocityMin) == 0x000400, "Member 'ATraceProjectile::MuzzleVelocityMin' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, MuzzleVelocityMax) == 0x000404, "Member 'ATraceProjectile::MuzzleVelocityMax' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, Spread) == 0x000408, "Member 'ATraceProjectile::Spread' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, Mass) == 0x00040C, "Member 'ATraceProjectile::Mass' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, Diameter) == 0x000410, "Member 'ATraceProjectile::Diameter' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, FormFactor) == 0x000414, "Member 'ATraceProjectile::FormFactor' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, MachDragCurve) == 0x000418, "Member 'ATraceProjectile::MachDragCurve' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, GrazingAngleExponent) == 0x000420, "Member 'ATraceProjectile::GrazingAngleExponent' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, MinPenetration) == 0x000424, "Member 'ATraceProjectile::MinPenetration' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, MaxPenetration) == 0x000428, "Member 'ATraceProjectile::MaxPenetration' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, PenetrationNormalization) == 0x00042C, "Member 'ATraceProjectile::PenetrationNormalization' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, PenetrationNormalizationGrazing) == 0x000430, "Member 'ATraceProjectile::PenetrationNormalizationGrazing' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, PenetrationEntryAngleSpread) == 0x000434, "Member 'ATraceProjectile::PenetrationEntryAngleSpread' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, PenetrationExitAngleSpread) == 0x000438, "Member 'ATraceProjectile::PenetrationExitAngleSpread' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, RicochetProbability) == 0x00043C, "Member 'ATraceProjectile::RicochetProbability' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, RicochetProbabilityGrazing) == 0x000440, "Member 'ATraceProjectile::RicochetProbabilityGrazing' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, RicochetRestitution) == 0x000444, "Member 'ATraceProjectile::RicochetRestitution' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, RicochetFriction) == 0x000448, "Member 'ATraceProjectile::RicochetFriction' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, RicochetSpread) == 0x00044C, "Member 'ATraceProjectile::RicochetSpread' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, SpeedControlsRicochetProbability) == 0x000450, "Member 'ATraceProjectile::SpeedControlsRicochetProbability' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, AddImpulse) == 0x000451, "Member 'ATraceProjectile::AddImpulse' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, ImpulseMultiplier) == 0x000454, "Member 'ATraceProjectile::ImpulseMultiplier' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, DefaultPenTraceType) == 0x000458, "Member 'ATraceProjectile::DefaultPenTraceType' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, MaterialResponseMap) == 0x000460, "Member 'ATraceProjectile::MaterialResponseMap' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, MaterialDensityControlsPenetrationDepth) == 0x000468, "Member 'ATraceProjectile::MaterialDensityControlsPenetrationDepth' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, MaterialRestitutionControlsRicochet) == 0x000469, "Member 'ATraceProjectile::MaterialRestitutionControlsRicochet' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, AllowComponentCollisions) == 0x00046A, "Member 'ATraceProjectile::AllowComponentCollisions' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, TraceChannel) == 0x00046B, "Member 'ATraceProjectile::TraceChannel' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, TraceComplex) == 0x00046C, "Member 'ATraceProjectile::TraceComplex' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, CollisionMargin) == 0x000470, "Member 'ATraceProjectile::CollisionMargin' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, DespawnVelocity) == 0x000474, "Member 'ATraceProjectile::DespawnVelocity' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, IgnoredActors) == 0x000478, "Member 'ATraceProjectile::IgnoredActors' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, DoFirstStepImmediately) == 0x000488, "Member 'ATraceProjectile::DoFirstStepImmediately' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, RandomFirstStepDelta) == 0x000489, "Member 'ATraceProjectile::RandomFirstStepDelta' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, MaxTracesPerStep) == 0x00048C, "Member 'ATraceProjectile::MaxTracesPerStep' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, Retrace) == 0x000490, "Member 'ATraceProjectile::Retrace' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, RetraceOnAnotherChannel) == 0x000491, "Member 'ATraceProjectile::RetraceOnAnotherChannel' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, RetraceChannel) == 0x000492, "Member 'ATraceProjectile::RetraceChannel' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, RotateActor) == 0x000493, "Member 'ATraceProjectile::RotateActor' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, RotateRandomRoll) == 0x000494, "Member 'ATraceProjectile::RotateRandomRoll' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, EnablePooling) == 0x000495, "Member 'ATraceProjectile::EnablePooling' has a wrong offset!");
static_assert(offsetof(ATraceProjectile, TraceFX) == 0x000498, "Member 'ATraceProjectile::TraceFX' has a wrong offset!");

// Class POLYGON.PG_PlayerState_Menu
// 0x0008 (0x03C8 - 0x03C0)
class APG_PlayerState_Menu : public APG_PlayerState_Base
{
public:
	class UInventoryComponent_Menu*               InventoryComponent;                                // 0x03C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PG_PlayerState_Menu">();
	}
	static class APG_PlayerState_Menu* GetDefaultObj()
	{
		return GetDefaultObjImpl<APG_PlayerState_Menu>();
	}
};
static_assert(alignof(APG_PlayerState_Menu) == 0x000008, "Wrong alignment on APG_PlayerState_Menu");
static_assert(sizeof(APG_PlayerState_Menu) == 0x0003C8, "Wrong size on APG_PlayerState_Menu");
static_assert(offsetof(APG_PlayerState_Menu, InventoryComponent) == 0x0003C0, "Member 'APG_PlayerState_Menu::InventoryComponent' has a wrong offset!");

// Class POLYGON.Bullet_Casing_General
// 0x0018 (0x02A8 - 0x0290)
class ABullet_Casing_General final : public AActor
{
public:
	class USoundBase*                             SoundDrop;                                         // 0x0290(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   Mesh;                                              // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UProjectileMovementComponent*           ProjectileMovementComponent;                       // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Bullet_Casing_General">();
	}
	static class ABullet_Casing_General* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABullet_Casing_General>();
	}
};
static_assert(alignof(ABullet_Casing_General) == 0x000008, "Wrong alignment on ABullet_Casing_General");
static_assert(sizeof(ABullet_Casing_General) == 0x0002A8, "Wrong size on ABullet_Casing_General");
static_assert(offsetof(ABullet_Casing_General, SoundDrop) == 0x000290, "Member 'ABullet_Casing_General::SoundDrop' has a wrong offset!");
static_assert(offsetof(ABullet_Casing_General, Mesh) == 0x000298, "Member 'ABullet_Casing_General::Mesh' has a wrong offset!");
static_assert(offsetof(ABullet_Casing_General, ProjectileMovementComponent) == 0x0002A0, "Member 'ABullet_Casing_General::ProjectileMovementComponent' has a wrong offset!");

// Class POLYGON.PlayerCoreComponent
// 0x00F8 (0x0198 - 0x00A0)
class UPlayerCoreComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnTotalProgress;                                   // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNewLevelReceived;                                // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAddedGameScore;                                  // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNotifyPossibilityUnlockModule;                   // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C1B[0x8];                                     // 0x00E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InitialTotalProgress;                              // 0x00E8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         TotalProgress;                                     // 0x00EC(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHasVipStatus;                                     // 0x00F0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C1C[0xA7];                                    // 0x00F1(0x00A7)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FLevelInfo GetLevelByProgress(const int32 Progress);
	static struct FLevelInfo GetNextLevelByLevelID(const class FName LevelID);

	void AddCredits(int32 Param_AddCredits);
	void NotifyAddedGameScore_client(const TArray<struct FScoreInfo>& ScoreInfos);
	void OnRep_TotalProgress();
	void Reset();
	void UpdatePlayerCombinedInfo(const TArray<EModifiedData>& ModifiedData, const class FString& CustomDelegateString);

	struct FLevelInfo GetCurrentLevelInfo() const;
	struct FLevelInfo GetNextLevelInfo() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerCoreComponent">();
	}
	static class UPlayerCoreComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerCoreComponent>();
	}
};
static_assert(alignof(UPlayerCoreComponent) == 0x000008, "Wrong alignment on UPlayerCoreComponent");
static_assert(sizeof(UPlayerCoreComponent) == 0x000198, "Wrong size on UPlayerCoreComponent");
static_assert(offsetof(UPlayerCoreComponent, OnTotalProgress) == 0x0000A0, "Member 'UPlayerCoreComponent::OnTotalProgress' has a wrong offset!");
static_assert(offsetof(UPlayerCoreComponent, OnNewLevelReceived) == 0x0000B0, "Member 'UPlayerCoreComponent::OnNewLevelReceived' has a wrong offset!");
static_assert(offsetof(UPlayerCoreComponent, OnAddedGameScore) == 0x0000C0, "Member 'UPlayerCoreComponent::OnAddedGameScore' has a wrong offset!");
static_assert(offsetof(UPlayerCoreComponent, OnNotifyPossibilityUnlockModule) == 0x0000D0, "Member 'UPlayerCoreComponent::OnNotifyPossibilityUnlockModule' has a wrong offset!");
static_assert(offsetof(UPlayerCoreComponent, InitialTotalProgress) == 0x0000E8, "Member 'UPlayerCoreComponent::InitialTotalProgress' has a wrong offset!");
static_assert(offsetof(UPlayerCoreComponent, TotalProgress) == 0x0000EC, "Member 'UPlayerCoreComponent::TotalProgress' has a wrong offset!");
static_assert(offsetof(UPlayerCoreComponent, bHasVipStatus) == 0x0000F0, "Member 'UPlayerCoreComponent::bHasVipStatus' has a wrong offset!");

// Class POLYGON.ChatSystemComponent
// 0x0010 (0x00B0 - 0x00A0)
class UChatSystemComponent final : public UActorComponent
{
public:
	TArray<struct FGameChatMessage>               ChatHistory;                                       // 0x00A0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void SendMessage_Server(const struct FGameChatMessage& Message);
	void SentMessage_Multicast(const struct FGameChatMessage& Message);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChatSystemComponent">();
	}
	static class UChatSystemComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChatSystemComponent>();
	}
};
static_assert(alignof(UChatSystemComponent) == 0x000008, "Wrong alignment on UChatSystemComponent");
static_assert(sizeof(UChatSystemComponent) == 0x0000B0, "Wrong size on UChatSystemComponent");
static_assert(offsetof(UChatSystemComponent, ChatHistory) == 0x0000A0, "Member 'UChatSystemComponent::ChatHistory' has a wrong offset!");

// Class POLYGON.ReservedSlot
// 0x0050 (0x0078 - 0x0028)
class UReservedSlot final : public UObject
{
public:
	uint8                                         Pad_2C1E[0x50];                                    // 0x0028(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReservedSlot">();
	}
	static class UReservedSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReservedSlot>();
	}
};
static_assert(alignof(UReservedSlot) == 0x000008, "Wrong alignment on UReservedSlot");
static_assert(sizeof(UReservedSlot) == 0x000078, "Wrong size on UReservedSlot");

// Class POLYGON.GeneralBackendComponent
// 0x0040 (0x00E0 - 0x00A0)
class UGeneralBackendComponent : public UActorComponent
{
public:
	uint8                                         Pad_2C1F[0x40];                                    // 0x00A0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeneralBackendComponent">();
	}
	static class UGeneralBackendComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeneralBackendComponent>();
	}
};
static_assert(alignof(UGeneralBackendComponent) == 0x000008, "Wrong alignment on UGeneralBackendComponent");
static_assert(sizeof(UGeneralBackendComponent) == 0x0000E0, "Wrong size on UGeneralBackendComponent");

// Class POLYGON.ServerBackendComponent
// 0x0000 (0x00E0 - 0x00E0)
class UServerBackendComponent final : public UGeneralBackendComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ServerBackendComponent">();
	}
	static class UServerBackendComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UServerBackendComponent>();
	}
};
static_assert(alignof(UServerBackendComponent) == 0x000008, "Wrong alignment on UServerBackendComponent");
static_assert(sizeof(UServerBackendComponent) == 0x0000E0, "Wrong size on UServerBackendComponent");

// Class POLYGON.ClientBackendComponent
// 0x0040 (0x0120 - 0x00E0)
class UClientBackendComponent final : public UGeneralBackendComponent
{
public:
	FMulticastInlineDelegateProperty_             OnSetPlayerId;                                     // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdatePlayerCombinedInfo;                        // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	class FString                                 PlayerMasterId;                                    // 0x0100(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlayFabJsonObject*                     PlayerCombinedInfo;                                // 0x0110(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlayFabJsonObject*                     PlayerExperiments;                                 // 0x0118(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static bool IsClientLoggedIn();

	void GiveVipLocal(const class FString& ID);
	void SerPlayerExperiments(class UPlayFabJsonObject* Experiments);
	void SetPlayerCombinedInfo(class UPlayFabJsonObject* NewPlayerCombinedInfo, const TArray<EModifiedData>& ModifiedData, const class FString& CustomDelegateString);
	void SetPlayerId(const class FString& NewPlayerMasterId);

	class UPlayFabJsonObject* GetPlayerCombinedInfo() const;
	class UPlayFabJsonObject* GetPlayerExperiments() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClientBackendComponent">();
	}
	static class UClientBackendComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClientBackendComponent>();
	}
};
static_assert(alignof(UClientBackendComponent) == 0x000008, "Wrong alignment on UClientBackendComponent");
static_assert(sizeof(UClientBackendComponent) == 0x000120, "Wrong size on UClientBackendComponent");
static_assert(offsetof(UClientBackendComponent, OnSetPlayerId) == 0x0000E0, "Member 'UClientBackendComponent::OnSetPlayerId' has a wrong offset!");
static_assert(offsetof(UClientBackendComponent, OnUpdatePlayerCombinedInfo) == 0x0000F0, "Member 'UClientBackendComponent::OnUpdatePlayerCombinedInfo' has a wrong offset!");
static_assert(offsetof(UClientBackendComponent, PlayerMasterId) == 0x000100, "Member 'UClientBackendComponent::PlayerMasterId' has a wrong offset!");
static_assert(offsetof(UClientBackendComponent, PlayerCombinedInfo) == 0x000110, "Member 'UClientBackendComponent::PlayerCombinedInfo' has a wrong offset!");
static_assert(offsetof(UClientBackendComponent, PlayerExperiments) == 0x000118, "Member 'UClientBackendComponent::PlayerExperiments' has a wrong offset!");

// Class POLYGON.ServerGameInstance
// 0x0010 (0x0038 - 0x0028)
class UServerGameInstance final : public UObject
{
public:
	uint8                                         Pad_2C20[0x10];                                    // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool OnGSDKHealthCheck();
	void OnGSDKReadyForPlayers();
	void OnGSDKServerActive();
	void OnGSDKShutdown();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ServerGameInstance">();
	}
	static class UServerGameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UServerGameInstance>();
	}
};
static_assert(alignof(UServerGameInstance) == 0x000008, "Wrong alignment on UServerGameInstance");
static_assert(sizeof(UServerGameInstance) == 0x000038, "Wrong size on UServerGameInstance");

// Class POLYGON.ClientGameInstance
// 0x0060 (0x0088 - 0x0028)
class UClientGameInstance final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnSetMasterId;                                     // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FText                                   KickReason;                                        // 0x0038(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C21[0x10];                                    // 0x0050(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UPlayFabJsonObject*                     PlayerCombinedInfo;                                // 0x0060(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UUserEntry*>                     UsersCache;                                        // 0x0068(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C22[0x10];                                    // 0x0078(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleNetworkFailure(class UWorld* World, class UNetDriver* NetDriver, ENetworkFailure FailureType, const class FString& ErrorString);
	void SetPlayerCombinedInfo(class UPlayFabJsonObject* NewPlayerCombinedInfo);
	void SetPlayerId(const class FString& NewPlayerMasterId);
	void SetServerTime(const struct FDateTime& ServerTime);

	class UPlayFabJsonObject* GetPlayerCombinedInfo() const;
	class FString GetPlayerMasterId() const;
	struct FDateTime GetServerTime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClientGameInstance">();
	}
	static class UClientGameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClientGameInstance>();
	}
};
static_assert(alignof(UClientGameInstance) == 0x000008, "Wrong alignment on UClientGameInstance");
static_assert(sizeof(UClientGameInstance) == 0x000088, "Wrong size on UClientGameInstance");
static_assert(offsetof(UClientGameInstance, OnSetMasterId) == 0x000028, "Member 'UClientGameInstance::OnSetMasterId' has a wrong offset!");
static_assert(offsetof(UClientGameInstance, KickReason) == 0x000038, "Member 'UClientGameInstance::KickReason' has a wrong offset!");
static_assert(offsetof(UClientGameInstance, PlayerCombinedInfo) == 0x000060, "Member 'UClientGameInstance::PlayerCombinedInfo' has a wrong offset!");
static_assert(offsetof(UClientGameInstance, UsersCache) == 0x000068, "Member 'UClientGameInstance::UsersCache' has a wrong offset!");

// Class POLYGON.SquadComponent
// 0x0050 (0x00F0 - 0x00A0)
class USquadComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnMembersUpdate;                                   // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnIsMemberMySquad;                                 // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCooldownStarted;                                 // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bIsMemberMySquad;                                  // 0x00D0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C24[0x7];                                     // 0x00D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class APG_PlayerState_Game*>           Members;                                           // 0x00D8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         CooldownCounter;                                   // 0x00E8(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C25[0x3];                                     // 0x00E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CooldownStartTime;                                 // 0x00EC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnRep_CooldownCounter();
	void OnRep_Members();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SquadComponent">();
	}
	static class USquadComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USquadComponent>();
	}
};
static_assert(alignof(USquadComponent) == 0x000008, "Wrong alignment on USquadComponent");
static_assert(sizeof(USquadComponent) == 0x0000F0, "Wrong size on USquadComponent");
static_assert(offsetof(USquadComponent, OnMembersUpdate) == 0x0000A0, "Member 'USquadComponent::OnMembersUpdate' has a wrong offset!");
static_assert(offsetof(USquadComponent, OnIsMemberMySquad) == 0x0000B0, "Member 'USquadComponent::OnIsMemberMySquad' has a wrong offset!");
static_assert(offsetof(USquadComponent, OnCooldownStarted) == 0x0000C0, "Member 'USquadComponent::OnCooldownStarted' has a wrong offset!");
static_assert(offsetof(USquadComponent, bIsMemberMySquad) == 0x0000D0, "Member 'USquadComponent::bIsMemberMySquad' has a wrong offset!");
static_assert(offsetof(USquadComponent, Members) == 0x0000D8, "Member 'USquadComponent::Members' has a wrong offset!");
static_assert(offsetof(USquadComponent, CooldownCounter) == 0x0000E8, "Member 'USquadComponent::CooldownCounter' has a wrong offset!");
static_assert(offsetof(USquadComponent, CooldownStartTime) == 0x0000EC, "Member 'USquadComponent::CooldownStartTime' has a wrong offset!");

// Class POLYGON.ControlPoint
// 0x0070 (0x0300 - 0x0290)
class AControlPoint final : public AActor
{
public:
	FMulticastInlineDelegateProperty_             OnCapturedTeam;                                    // 0x0290(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnIsCapture;                                       // 0x02A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeCapturePoints;                             // 0x02B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EControlPoint                                 ControlPointName;                                  // 0x02C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETeam                                         CapturedTeam;                                      // 0x02C1(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsCapture;                                        // 0x02C2(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C26[0x1];                                     // 0x02C3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CapturePointsAlphaTeam;                            // 0x02C4(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CapturePointsBravoTeam;                            // 0x02C8(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C27[0x4];                                     // 0x02CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class APG_PlayerState_Game*>           CapturePlayersAlphaTeam;                           // 0x02D0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class APG_PlayerState_Game*>           CapturePlayersBravoTeam;                           // 0x02E0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C28[0x8];                                     // 0x02F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        Root;                                              // 0x02F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnRep_CapturedTeam();
	void OnRep_IsCapture();

	bool ContainsCharacter(class ACharacter* Character) const;
	class FString GetControlPointNameAsOneLetter() const;
	class FString GetControlPointNameAsString() const;
	void OnRep_CapturePointsAlphaTeam() const;
	void OnRep_CapturePointsBravoTeam() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ControlPoint">();
	}
	static class AControlPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AControlPoint>();
	}
};
static_assert(alignof(AControlPoint) == 0x000008, "Wrong alignment on AControlPoint");
static_assert(sizeof(AControlPoint) == 0x000300, "Wrong size on AControlPoint");
static_assert(offsetof(AControlPoint, OnCapturedTeam) == 0x000290, "Member 'AControlPoint::OnCapturedTeam' has a wrong offset!");
static_assert(offsetof(AControlPoint, OnIsCapture) == 0x0002A0, "Member 'AControlPoint::OnIsCapture' has a wrong offset!");
static_assert(offsetof(AControlPoint, OnChangeCapturePoints) == 0x0002B0, "Member 'AControlPoint::OnChangeCapturePoints' has a wrong offset!");
static_assert(offsetof(AControlPoint, ControlPointName) == 0x0002C0, "Member 'AControlPoint::ControlPointName' has a wrong offset!");
static_assert(offsetof(AControlPoint, CapturedTeam) == 0x0002C1, "Member 'AControlPoint::CapturedTeam' has a wrong offset!");
static_assert(offsetof(AControlPoint, bIsCapture) == 0x0002C2, "Member 'AControlPoint::bIsCapture' has a wrong offset!");
static_assert(offsetof(AControlPoint, CapturePointsAlphaTeam) == 0x0002C4, "Member 'AControlPoint::CapturePointsAlphaTeam' has a wrong offset!");
static_assert(offsetof(AControlPoint, CapturePointsBravoTeam) == 0x0002C8, "Member 'AControlPoint::CapturePointsBravoTeam' has a wrong offset!");
static_assert(offsetof(AControlPoint, CapturePlayersAlphaTeam) == 0x0002D0, "Member 'AControlPoint::CapturePlayersAlphaTeam' has a wrong offset!");
static_assert(offsetof(AControlPoint, CapturePlayersBravoTeam) == 0x0002E0, "Member 'AControlPoint::CapturePlayersBravoTeam' has a wrong offset!");
static_assert(offsetof(AControlPoint, Root) == 0x0002F8, "Member 'AControlPoint::Root' has a wrong offset!");

// Class POLYGON.DataManagerLibrary
// 0x0000 (0x0028 - 0x0028)
class UDataManagerLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UDataContainerAsset* GetDataTableReferences();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DataManagerLibrary">();
	}
	static class UDataManagerLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDataManagerLibrary>();
	}
};
static_assert(alignof(UDataManagerLibrary) == 0x000008, "Wrong alignment on UDataManagerLibrary");
static_assert(sizeof(UDataManagerLibrary) == 0x000028, "Wrong size on UDataManagerLibrary");

// Class POLYGON.EOSPartyId
// 0x0010 (0x0038 - 0x0028)
class UEOSPartyId final : public UObject
{
public:
	uint8                                         Pad_2C2A[0x10];                                    // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FString ToString();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EOSPartyId">();
	}
	static class UEOSPartyId* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEOSPartyId>();
	}
};
static_assert(alignof(UEOSPartyId) == 0x000008, "Wrong alignment on UEOSPartyId");
static_assert(sizeof(UEOSPartyId) == 0x000038, "Wrong size on UEOSPartyId");

// Class POLYGON.EOSPartyMemberId
// 0x0010 (0x0038 - 0x0028)
class UEOSPartyMemberId final : public UObject
{
public:
	uint8                                         Pad_2C2B[0x10];                                    // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FString ToString();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EOSPartyMemberId">();
	}
	static class UEOSPartyMemberId* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEOSPartyMemberId>();
	}
};
static_assert(alignof(UEOSPartyMemberId) == 0x000008, "Wrong alignment on UEOSPartyMemberId");
static_assert(sizeof(UEOSPartyMemberId) == 0x000038, "Wrong size on UEOSPartyMemberId");

// Class POLYGON.EOSSubsystemAvanced
// 0x0008 (0x0038 - 0x0030)
class UEOSSubsystemAvanced final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_2C2C[0x8];                                     // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<class UEOSPartyId*> GetJoinedParties(const class UObject* WorldContextObject);
	TArray<class UEOSPartyMemberId*> GetPartyMembers(const class UObject* WorldContextObject, class UEOSPartyId* PartyId);
	void StartCreateParty(const class UObject* WorldContextObject, int32 PartyTypeId, TDelegate<void(bool WasSuccessful)> OnDone);
	void StartLogin(TDelegate<void(bool IsSuccessful, const class FString& ErrorMessage)> OnLoginComplete);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EOSSubsystemAvanced">();
	}
	static class UEOSSubsystemAvanced* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEOSSubsystemAvanced>();
	}
};
static_assert(alignof(UEOSSubsystemAvanced) == 0x000008, "Wrong alignment on UEOSSubsystemAvanced");
static_assert(sizeof(UEOSSubsystemAvanced) == 0x000038, "Wrong size on UEOSSubsystemAvanced");

// Class POLYGON.EventManagerComponent
// 0x0000 (0x00A0 - 0x00A0)
class UEventManagerComponent : public UActorComponent
{
public:
	void AmmoBoxAction();
	void OnAmmoBoxAction();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventManagerComponent">();
	}
	static class UEventManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventManagerComponent>();
	}
};
static_assert(alignof(UEventManagerComponent) == 0x000008, "Wrong alignment on UEventManagerComponent");
static_assert(sizeof(UEventManagerComponent) == 0x0000A0, "Wrong size on UEventManagerComponent");

// Class POLYGON.FOVManagerComponent
// 0x0020 (0x00C0 - 0x00A0)
class UFOVManagerComponent : public UActorComponent
{
public:
	float                                         AimingFOV_Alpha;                                   // 0x00A0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultCameraFOV;                                  // 0x00A4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CurrentCameraFOV;                                  // 0x00A8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DefaultMeshFOV;                                    // 0x00AC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CurrentMeshFOV;                                    // 0x00B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C2E[0x4];                                     // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialParameterCollection*           MaterialCollection_CorrectFOV;                     // 0x00B8(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void HardResetCameraFOV();
	void HardResetMeshFOV();
	void SetCameraFOV(const float NewCameraFOV);
	void SetDefaultCameraFOV(const float NewDefaultCameraFOV);
	void SetMeshFOV(const float NewMeshFOV);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FOVManagerComponent">();
	}
	static class UFOVManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFOVManagerComponent>();
	}
};
static_assert(alignof(UFOVManagerComponent) == 0x000008, "Wrong alignment on UFOVManagerComponent");
static_assert(sizeof(UFOVManagerComponent) == 0x0000C0, "Wrong size on UFOVManagerComponent");
static_assert(offsetof(UFOVManagerComponent, AimingFOV_Alpha) == 0x0000A0, "Member 'UFOVManagerComponent::AimingFOV_Alpha' has a wrong offset!");
static_assert(offsetof(UFOVManagerComponent, DefaultCameraFOV) == 0x0000A4, "Member 'UFOVManagerComponent::DefaultCameraFOV' has a wrong offset!");
static_assert(offsetof(UFOVManagerComponent, CurrentCameraFOV) == 0x0000A8, "Member 'UFOVManagerComponent::CurrentCameraFOV' has a wrong offset!");
static_assert(offsetof(UFOVManagerComponent, DefaultMeshFOV) == 0x0000AC, "Member 'UFOVManagerComponent::DefaultMeshFOV' has a wrong offset!");
static_assert(offsetof(UFOVManagerComponent, CurrentMeshFOV) == 0x0000B0, "Member 'UFOVManagerComponent::CurrentMeshFOV' has a wrong offset!");
static_assert(offsetof(UFOVManagerComponent, MaterialCollection_CorrectFOV) == 0x0000B8, "Member 'UFOVManagerComponent::MaterialCollection_CorrectFOV' has a wrong offset!");

// Class POLYGON.FOVManagerInterface
// 0x0000 (0x0028 - 0x0028)
class IFOVManagerInterface final : public IInterface
{
public:
	void SetCorrectiveFovMaterial(bool UseFovMaterial);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FOVManagerInterface">();
	}
	static class IFOVManagerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFOVManagerInterface>();
	}
};
static_assert(alignof(IFOVManagerInterface) == 0x000008, "Wrong alignment on IFOVManagerInterface");
static_assert(sizeof(IFOVManagerInterface) == 0x000028, "Wrong size on IFOVManagerInterface");

// Class POLYGON.GameSettings
// 0x0000 (0x0038 - 0x0038)
class UGameSettings final : public UDeveloperSettings
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameSettings">();
	}
	static class UGameSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameSettings>();
	}
};
static_assert(alignof(UGameSettings) == 0x000008, "Wrong alignment on UGameSettings");
static_assert(sizeof(UGameSettings) == 0x000038, "Wrong size on UGameSettings");

// Class POLYGON.GunModulesInfo
// 0x0010 (0x0040 - 0x0030)
class UGunModulesInfo final : public UDataAsset
{
public:
	TArray<struct FGunModuleInfo>                 Modules;                                           // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static struct FGunModuleInfo FindModule(const TArray<struct FGunModuleInfo>& Array, TSubclassOf<class AItem_Module_General> ModuleClass);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GunModulesInfo">();
	}
	static class UGunModulesInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGunModulesInfo>();
	}
};
static_assert(alignof(UGunModulesInfo) == 0x000008, "Wrong alignment on UGunModulesInfo");
static_assert(sizeof(UGunModulesInfo) == 0x000040, "Wrong size on UGunModulesInfo");
static_assert(offsetof(UGunModulesInfo, Modules) == 0x000030, "Member 'UGunModulesInfo::Modules' has a wrong offset!");

// Class POLYGON.HealthStatsComponent
// 0x0070 (0x0110 - 0x00A0)
class UHealthStatsComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnChangeHealth;                                    // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHealthProtection;                                // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnIsAlive;                                         // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Health;                                            // 0x00D0(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsAlive;                                          // 0x00D1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHealthProtection;                                 // 0x00D2(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C2F[0x1];                                     // 0x00D3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastTimeTakeDamage;                                // 0x00D4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Stamina;                                           // 0x00D8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C30[0x4];                                     // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPlayerAssist>                  KillAssists;                                       // 0x00E0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C31[0x20];                                    // 0x00F0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void KillSelf_server();
	void OnRep_Health(uint8 PreviousHealth);
	void OnRep_HealthProtection();

	int32 GetHealth() const;
	bool GetHealthProtection() const;
	int32 GetStamina() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HealthStatsComponent">();
	}
	static class UHealthStatsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHealthStatsComponent>();
	}
};
static_assert(alignof(UHealthStatsComponent) == 0x000008, "Wrong alignment on UHealthStatsComponent");
static_assert(sizeof(UHealthStatsComponent) == 0x000110, "Wrong size on UHealthStatsComponent");
static_assert(offsetof(UHealthStatsComponent, OnChangeHealth) == 0x0000A0, "Member 'UHealthStatsComponent::OnChangeHealth' has a wrong offset!");
static_assert(offsetof(UHealthStatsComponent, OnHealthProtection) == 0x0000B0, "Member 'UHealthStatsComponent::OnHealthProtection' has a wrong offset!");
static_assert(offsetof(UHealthStatsComponent, OnIsAlive) == 0x0000C0, "Member 'UHealthStatsComponent::OnIsAlive' has a wrong offset!");
static_assert(offsetof(UHealthStatsComponent, Health) == 0x0000D0, "Member 'UHealthStatsComponent::Health' has a wrong offset!");
static_assert(offsetof(UHealthStatsComponent, bIsAlive) == 0x0000D1, "Member 'UHealthStatsComponent::bIsAlive' has a wrong offset!");
static_assert(offsetof(UHealthStatsComponent, bHealthProtection) == 0x0000D2, "Member 'UHealthStatsComponent::bHealthProtection' has a wrong offset!");
static_assert(offsetof(UHealthStatsComponent, LastTimeTakeDamage) == 0x0000D4, "Member 'UHealthStatsComponent::LastTimeTakeDamage' has a wrong offset!");
static_assert(offsetof(UHealthStatsComponent, Stamina) == 0x0000D8, "Member 'UHealthStatsComponent::Stamina' has a wrong offset!");
static_assert(offsetof(UHealthStatsComponent, KillAssists) == 0x0000E0, "Member 'UHealthStatsComponent::KillAssists' has a wrong offset!");

// Class POLYGON.InspectManagerComponent
// 0x0028 (0x00C8 - 0x00A0)
class UInspectManagerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_2C32[0x28];                                    // 0x00A0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DisableInspect();
	void EnableInspect();
	void ResetRotation();
	void SetPivotOffset(const struct FVector2D& Offset);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InspectManagerComponent">();
	}
	static class UInspectManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInspectManagerComponent>();
	}
};
static_assert(alignof(UInspectManagerComponent) == 0x000008, "Wrong alignment on UInspectManagerComponent");
static_assert(sizeof(UInspectManagerComponent) == 0x0000C8, "Wrong size on UInspectManagerComponent");

// Class POLYGON.InteractInterface
// 0x0000 (0x0028 - 0x0028)
class IInteractInterface final : public IInterface
{
public:
	void SetPlayerLooks(class APG_Game_Character* Character, const bool bIsLooks);
	void StartInteract(class APG_Game_Character* Character);
	void StopInteract(class APG_Game_Character* Character);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractInterface">();
	}
	static class IInteractInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInteractInterface>();
	}
};
static_assert(alignof(IInteractInterface) == 0x000008, "Wrong alignment on IInteractInterface");
static_assert(sizeof(IInteractInterface) == 0x000028, "Wrong size on IInteractInterface");

// Class POLYGON.InventoryComponent_Base
// 0x0038 (0x00D8 - 0x00A0)
class UInventoryComponent_Base : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnSetPrimaryGun;                                   // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSetSecondaryGun;                                 // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AItem_Gun_General*                      PrimaryGun;                                        // 0x00C0(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AItem_Gun_General*                      SecondaryGun;                                      // 0x00C8(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AItem_Watch_General>        WatchClass;                                        // 0x00D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class AItem_Gun_General* GetGunBySlot(EGunSlot GunSlot);
	void OnRep_PrimaryGun(class AItem_Gun_General* OldGun);
	void OnRep_SecondaryGun(class AItem_Gun_General* OldGun);
	void UpdatePlayerCombinedInfo(const TArray<EModifiedData>& ModifiedData, const class FString& CustomDelegateString);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryComponent_Base">();
	}
	static class UInventoryComponent_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryComponent_Base>();
	}
};
static_assert(alignof(UInventoryComponent_Base) == 0x000008, "Wrong alignment on UInventoryComponent_Base");
static_assert(sizeof(UInventoryComponent_Base) == 0x0000D8, "Wrong size on UInventoryComponent_Base");
static_assert(offsetof(UInventoryComponent_Base, OnSetPrimaryGun) == 0x0000A0, "Member 'UInventoryComponent_Base::OnSetPrimaryGun' has a wrong offset!");
static_assert(offsetof(UInventoryComponent_Base, OnSetSecondaryGun) == 0x0000B0, "Member 'UInventoryComponent_Base::OnSetSecondaryGun' has a wrong offset!");
static_assert(offsetof(UInventoryComponent_Base, PrimaryGun) == 0x0000C0, "Member 'UInventoryComponent_Base::PrimaryGun' has a wrong offset!");
static_assert(offsetof(UInventoryComponent_Base, SecondaryGun) == 0x0000C8, "Member 'UInventoryComponent_Base::SecondaryGun' has a wrong offset!");
static_assert(offsetof(UInventoryComponent_Base, WatchClass) == 0x0000D0, "Member 'UInventoryComponent_Base::WatchClass' has a wrong offset!");

// Class POLYGON.InventoryComponent_Game
// 0x0038 (0x0110 - 0x00D8)
class UInventoryComponent_Game final : public UInventoryComponent_Base
{
public:
	FMulticastInlineDelegateProperty_             OnSetCurrentGun;                                   // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeNumberGrenades;                            // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AItem_Gun_General*                      CurrentGun;                                        // 0x00F8(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         GrenadesNumber;                                    // 0x0100(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C35[0xF];                                     // 0x0101(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddGrenate_server(const uint8 Number);
	TArray<class FString> EquipItems(const TArray<class FString>& ItemsInstanceId, const bool CallUpdate);
	void OnRep_CurrentGun(class AItem_Gun_General* PreviousGun);
	void OnRep_GrenadesNumber();
	void RequestEquipItems_server(const TArray<class FString>& ItemsInstanceId);
	void RequestSetGunModules_server(class AItem_Gun_General* GunRef, const class FString& ModuleId, const EGunModuleType ModuleType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryComponent_Game">();
	}
	static class UInventoryComponent_Game* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryComponent_Game>();
	}
};
static_assert(alignof(UInventoryComponent_Game) == 0x000008, "Wrong alignment on UInventoryComponent_Game");
static_assert(sizeof(UInventoryComponent_Game) == 0x000110, "Wrong size on UInventoryComponent_Game");
static_assert(offsetof(UInventoryComponent_Game, OnSetCurrentGun) == 0x0000D8, "Member 'UInventoryComponent_Game::OnSetCurrentGun' has a wrong offset!");
static_assert(offsetof(UInventoryComponent_Game, OnChangeNumberGrenades) == 0x0000E8, "Member 'UInventoryComponent_Game::OnChangeNumberGrenades' has a wrong offset!");
static_assert(offsetof(UInventoryComponent_Game, CurrentGun) == 0x0000F8, "Member 'UInventoryComponent_Game::CurrentGun' has a wrong offset!");
static_assert(offsetof(UInventoryComponent_Game, GrenadesNumber) == 0x000100, "Member 'UInventoryComponent_Game::GrenadesNumber' has a wrong offset!");

// Class POLYGON.InventoryComponent_Menu
// 0x0000 (0x00D8 - 0x00D8)
class UInventoryComponent_Menu final : public UInventoryComponent_Base
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryComponent_Menu">();
	}
	static class UInventoryComponent_Menu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryComponent_Menu>();
	}
};
static_assert(alignof(UInventoryComponent_Menu) == 0x000008, "Wrong alignment on UInventoryComponent_Menu");
static_assert(sizeof(UInventoryComponent_Menu) == 0x0000D8, "Wrong size on UInventoryComponent_Menu");

// Class POLYGON.Item_General
// 0x0068 (0x02F8 - 0x0290)
class AItem_General : public AActor
{
public:
	class FString                                 ItemId;                                            // 0x0290(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EItemType                                     ItemType;                                          // 0x02A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C38[0x7];                                     // 0x02A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ItemName;                                          // 0x02A8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              ItemIcon;                                          // 0x02C0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDataContainerObjectWrapper            CustomData;                                        // 0x02F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Item_General">();
	}
	static class AItem_General* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItem_General>();
	}
};
static_assert(alignof(AItem_General) == 0x000008, "Wrong alignment on AItem_General");
static_assert(sizeof(AItem_General) == 0x0002F8, "Wrong size on AItem_General");
static_assert(offsetof(AItem_General, ItemId) == 0x000290, "Member 'AItem_General::ItemId' has a wrong offset!");
static_assert(offsetof(AItem_General, ItemType) == 0x0002A0, "Member 'AItem_General::ItemType' has a wrong offset!");
static_assert(offsetof(AItem_General, ItemName) == 0x0002A8, "Member 'AItem_General::ItemName' has a wrong offset!");
static_assert(offsetof(AItem_General, ItemIcon) == 0x0002C0, "Member 'AItem_General::ItemIcon' has a wrong offset!");
static_assert(offsetof(AItem_General, CustomData) == 0x0002F0, "Member 'AItem_General::CustomData' has a wrong offset!");

// Class POLYGON.Item_Grenade_General
// 0x0060 (0x0358 - 0x02F8)
class AItem_Grenade_General final : public AItem_General
{
public:
	float                                         GrenadeDamage;                                     // 0x02F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C39[0x4];                                     // 0x02FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize                    ReplicatedPosition;                                // 0x0300(0x0018)(Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystem*                        ExplosionFX;                                       // 0x0318(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundBase*                             SoundExplosion;                                    // 0x0320(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UCameraShakeBase>           ExplosionCameraShakeFirst;                         // 0x0328(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UCameraShakeBase>           ExplosionCameraShakeSecond;                        // 0x0330(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UCameraShakeBase>           GrenadeThrowCameraShake;                           // 0x0338(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   Mesh;                                              // 0x0340(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URadialForceComponent*                  RadialForce;                                       // 0x0348(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USphereComponent*                       GrenadeSphereRadius;                               // 0x0350(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void NotifyThrow_server(const struct FVector_NetQuantize& StartPosition, const struct FVector_NetQuantize& Impulse);
	void OnGrenadeThrow();
	void OnMeshHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnRep_ReplicatedPosition();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Item_Grenade_General">();
	}
	static class AItem_Grenade_General* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItem_Grenade_General>();
	}
};
static_assert(alignof(AItem_Grenade_General) == 0x000008, "Wrong alignment on AItem_Grenade_General");
static_assert(sizeof(AItem_Grenade_General) == 0x000358, "Wrong size on AItem_Grenade_General");
static_assert(offsetof(AItem_Grenade_General, GrenadeDamage) == 0x0002F8, "Member 'AItem_Grenade_General::GrenadeDamage' has a wrong offset!");
static_assert(offsetof(AItem_Grenade_General, ReplicatedPosition) == 0x000300, "Member 'AItem_Grenade_General::ReplicatedPosition' has a wrong offset!");
static_assert(offsetof(AItem_Grenade_General, ExplosionFX) == 0x000318, "Member 'AItem_Grenade_General::ExplosionFX' has a wrong offset!");
static_assert(offsetof(AItem_Grenade_General, SoundExplosion) == 0x000320, "Member 'AItem_Grenade_General::SoundExplosion' has a wrong offset!");
static_assert(offsetof(AItem_Grenade_General, ExplosionCameraShakeFirst) == 0x000328, "Member 'AItem_Grenade_General::ExplosionCameraShakeFirst' has a wrong offset!");
static_assert(offsetof(AItem_Grenade_General, ExplosionCameraShakeSecond) == 0x000330, "Member 'AItem_Grenade_General::ExplosionCameraShakeSecond' has a wrong offset!");
static_assert(offsetof(AItem_Grenade_General, GrenadeThrowCameraShake) == 0x000338, "Member 'AItem_Grenade_General::GrenadeThrowCameraShake' has a wrong offset!");
static_assert(offsetof(AItem_Grenade_General, Mesh) == 0x000340, "Member 'AItem_Grenade_General::Mesh' has a wrong offset!");
static_assert(offsetof(AItem_Grenade_General, RadialForce) == 0x000348, "Member 'AItem_Grenade_General::RadialForce' has a wrong offset!");
static_assert(offsetof(AItem_Grenade_General, GrenadeSphereRadius) == 0x000350, "Member 'AItem_Grenade_General::GrenadeSphereRadius' has a wrong offset!");

// Class POLYGON.Item_Gun_General
// 0x0488 (0x0780 - 0x02F8)
class AItem_Gun_General : public AItem_General
{
public:
	uint8                                         Pad_2C3A[0x8];                                     // 0x02F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnChangeCurrentNumberAmmo;                         // 0x0300(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeStockAmmo;                                 // 0x0310(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSetGunModules;                                   // 0x0320(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C3B[0x8];                                     // 0x0330(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnApplyGunDamage;                                  // 0x0338(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C3C[0x18];                                    // 0x0348(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              GunWhileIcon;                                      // 0x0360(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         LevelRequired;                                     // 0x0390(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAvailable;                                      // 0x0394(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGunClass                                     GunClass;                                          // 0x0395(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGunSlot                                      GunSlot;                                           // 0x0396(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGunShootingType                              GunShootingType;                                   // 0x0397(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   ProjectileClass;                                   // 0x0398(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BulletVelocityMultiplier;                          // 0x03C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C3D[0x4];                                     // 0x03CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 Levels;                                            // 0x03D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	int32                                         GunDamage;                                         // 0x03E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamageMultiplierHead;                              // 0x03E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxMagazineAmmo;                                   // 0x03E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxStockAmmo;                                      // 0x03EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeBetweenShots;                                  // 0x03F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GunUpRecoil;                                       // 0x03F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GunBackwardRecoil;                                 // 0x03F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GunRecoilAlphaPerShot;                             // 0x03FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GunRecoilLift;                                     // 0x0400(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GunRecoilControlMultiplier;                        // 0x0404(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FirstShotKickMultiplier;                           // 0x0408(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AccuracyHip;                                       // 0x040C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpreadShot;                                        // 0x0410(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Mobility;                                          // 0x0414(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AimDownTimeMultiplier;                             // 0x0418(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReloadTimeMultiplier;                              // 0x041C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DrawTimeMultiplier;                                // 0x0420(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C3E[0x4];                                     // 0x0424(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UGunModulesInfo>         RelatedModulesInfo;                                // 0x0428(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   ProgressWidget;                                    // 0x0458(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        SleeveFX;                                          // 0x0488(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             SoundBulletCasingDrop;                             // 0x0490(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCameraShakeBase>           ShotCameraShake;                                   // 0x0498(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          IdleCharacterAnimation;                            // 0x04A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           ReloadCharacterAnimation;                          // 0x04A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReloadCharacterAnimationAimingStartTime;           // 0x04B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C3F[0x4];                                     // 0x04B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           ReloadFullCharacterAnimation;                      // 0x04B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReloadFullCharacterAnimationAimingStartTime;       // 0x04C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C40[0x4];                                     // 0x04C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           ShotCharacterAnimation;                            // 0x04C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           EndShotCharacterAnimation;                         // 0x04D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           BoltCharacterAnimation;                            // 0x04D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           GrenadeThrowAdditiveAnimation;                     // 0x04E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           EquipAnimation;                                    // 0x04E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           AimingEquipAnimation;                              // 0x04F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           HolsterAnimation;                                  // 0x04F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           AimingAnimation;                                   // 0x0500(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      ShotGunAnimation;                                  // 0x0508(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          BoltGunAnimation;                                  // 0x0510(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      ReloadGunAnimation;                                // 0x0518(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      ReloadFullGunAnimation;                            // 0x0520(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      NoAmmoGunAnimation;                                // 0x0528(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                FirstPersonGunPosition;                            // 0x0530(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                ThirdPersonGunPosition;                            // 0x0548(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             LeftHandOffset;                                    // 0x0560(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                SprintLiftGun;                                     // 0x05C0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C41[0x8];                                     // 0x05D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             WatchOffset;                                       // 0x05E0(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class USoundBase>              SoundShot_FP;                                      // 0x0640(0x0030)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class USoundBase>              SoundShot_TP;                                      // 0x0670(0x0030)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             SoundBlankShot;                                    // 0x06A0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             SoundAiming;                                       // 0x06A8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class USoundBase>>      CustomSounds;                                      // 0x06B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         CallHardReset;                                     // 0x06C0(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C42[0x3];                                     // 0x06C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentMagazineAmmo;                               // 0x06C4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint16                                        CurrentStockAmmo;                                  // 0x06C8(0x0002)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         ReloadCaller;                                      // 0x06CA(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C43[0x5];                                     // 0x06CB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class ATraceProjectile>> PoolProjectiles;                                   // 0x06D0(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class ABullet_Casing_General>> PoolBulletCasings;                                 // 0x06E0(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C44[0x4];                                     // 0x06F0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentSpread;                                     // 0x06F4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UClass*>                         CurrentGunModuleClasses;                           // 0x06F8(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	TArray<class AItem_Module_General*>           CurrentGunModuleReferences;                        // 0x0708(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	struct FGunShot                               GunShot;                                           // 0x0718(0x0020)(Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector_NetQuantize                    GunHitOfShortShot;                                 // 0x0738(0x0018)(Net, Transient, RepNotify, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C45[0x8];                                     // 0x0750(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAudioComponent*                        ActiveSoundShot;                                   // 0x0758(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlayFabJsonObject*                     ItemReference;                                     // 0x0760(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 GunMesh;                                           // 0x0768(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   Magazine;                                          // 0x0770(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C46[0x8];                                     // 0x0778(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddStockAmmo_server(const int8 AddAmmo);
	void CockBolt_multicast();
	void CockBolt_server();
	struct FVector GetForwardShot();
	void NotifyGrantedModulesDataContainer_client(const class FString& ItemInstanceId);
	void NotifyGrantedProgressDataContainer_client(const class FString& ItemInstanceId);
	void NotifyServerHit(const struct FGunHitOnCharacter& HitOnCharacter);
	void NotifyServerHitWithEnergy(const struct FGunHitOnCharacter& HitOnCharacter, const uint8 Energy);
	void NotifyServerOfShot(const struct FGunShot& Param_GunShot);
	void NotifyServerTraceHit(const struct FGunHitOnCharacter& HitOnCharacter);
	void OnRep_CallHardReset(uint8 PreviousValue);
	void OnRep_CurrentGunModuleClasses();
	void OnRep_CurrentStockAmmo();
	void OnRep_GunHitOfShortShot(const struct FVector_NetQuantize& PreviousValue);
	void OnRep_GunShot(const struct FGunShot& PreviousShot);
	void OnRep_ReloadCaller(uint8 PreviousValue);
	void OnSetPlayerState();
	void RequestReload_server(uint8 CurrentNumberAmmo);
	void SetGunModules(class UPlayFabJsonObject* Modules);
	void UpdateAmmoCount_server(uint8 CurrentNumberAmmo);
	void UpdatePlayerCombinedInfo(const TArray<EModifiedData>& ModifiedData, const class FString& CustomDelegateString);

	int32 GetCurrentStockAmmo() const;
	class UPlayFabJsonObject* GetItemReference() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Item_Gun_General">();
	}
	static class AItem_Gun_General* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItem_Gun_General>();
	}
};
static_assert(alignof(AItem_Gun_General) == 0x000010, "Wrong alignment on AItem_Gun_General");
static_assert(sizeof(AItem_Gun_General) == 0x000780, "Wrong size on AItem_Gun_General");
static_assert(offsetof(AItem_Gun_General, OnChangeCurrentNumberAmmo) == 0x000300, "Member 'AItem_Gun_General::OnChangeCurrentNumberAmmo' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, OnChangeStockAmmo) == 0x000310, "Member 'AItem_Gun_General::OnChangeStockAmmo' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, OnSetGunModules) == 0x000320, "Member 'AItem_Gun_General::OnSetGunModules' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, OnApplyGunDamage) == 0x000338, "Member 'AItem_Gun_General::OnApplyGunDamage' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, GunWhileIcon) == 0x000360, "Member 'AItem_Gun_General::GunWhileIcon' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, LevelRequired) == 0x000390, "Member 'AItem_Gun_General::LevelRequired' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, bIsAvailable) == 0x000394, "Member 'AItem_Gun_General::bIsAvailable' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, GunClass) == 0x000395, "Member 'AItem_Gun_General::GunClass' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, GunSlot) == 0x000396, "Member 'AItem_Gun_General::GunSlot' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, GunShootingType) == 0x000397, "Member 'AItem_Gun_General::GunShootingType' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, ProjectileClass) == 0x000398, "Member 'AItem_Gun_General::ProjectileClass' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, BulletVelocityMultiplier) == 0x0003C8, "Member 'AItem_Gun_General::BulletVelocityMultiplier' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, Levels) == 0x0003D0, "Member 'AItem_Gun_General::Levels' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, GunDamage) == 0x0003E0, "Member 'AItem_Gun_General::GunDamage' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, DamageMultiplierHead) == 0x0003E4, "Member 'AItem_Gun_General::DamageMultiplierHead' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, MaxMagazineAmmo) == 0x0003E8, "Member 'AItem_Gun_General::MaxMagazineAmmo' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, MaxStockAmmo) == 0x0003EC, "Member 'AItem_Gun_General::MaxStockAmmo' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, TimeBetweenShots) == 0x0003F0, "Member 'AItem_Gun_General::TimeBetweenShots' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, GunUpRecoil) == 0x0003F4, "Member 'AItem_Gun_General::GunUpRecoil' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, GunBackwardRecoil) == 0x0003F8, "Member 'AItem_Gun_General::GunBackwardRecoil' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, GunRecoilAlphaPerShot) == 0x0003FC, "Member 'AItem_Gun_General::GunRecoilAlphaPerShot' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, GunRecoilLift) == 0x000400, "Member 'AItem_Gun_General::GunRecoilLift' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, GunRecoilControlMultiplier) == 0x000404, "Member 'AItem_Gun_General::GunRecoilControlMultiplier' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, FirstShotKickMultiplier) == 0x000408, "Member 'AItem_Gun_General::FirstShotKickMultiplier' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, AccuracyHip) == 0x00040C, "Member 'AItem_Gun_General::AccuracyHip' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, SpreadShot) == 0x000410, "Member 'AItem_Gun_General::SpreadShot' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, Mobility) == 0x000414, "Member 'AItem_Gun_General::Mobility' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, AimDownTimeMultiplier) == 0x000418, "Member 'AItem_Gun_General::AimDownTimeMultiplier' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, ReloadTimeMultiplier) == 0x00041C, "Member 'AItem_Gun_General::ReloadTimeMultiplier' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, DrawTimeMultiplier) == 0x000420, "Member 'AItem_Gun_General::DrawTimeMultiplier' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, RelatedModulesInfo) == 0x000428, "Member 'AItem_Gun_General::RelatedModulesInfo' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, ProgressWidget) == 0x000458, "Member 'AItem_Gun_General::ProgressWidget' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, SleeveFX) == 0x000488, "Member 'AItem_Gun_General::SleeveFX' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, SoundBulletCasingDrop) == 0x000490, "Member 'AItem_Gun_General::SoundBulletCasingDrop' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, ShotCameraShake) == 0x000498, "Member 'AItem_Gun_General::ShotCameraShake' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, IdleCharacterAnimation) == 0x0004A0, "Member 'AItem_Gun_General::IdleCharacterAnimation' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, ReloadCharacterAnimation) == 0x0004A8, "Member 'AItem_Gun_General::ReloadCharacterAnimation' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, ReloadCharacterAnimationAimingStartTime) == 0x0004B0, "Member 'AItem_Gun_General::ReloadCharacterAnimationAimingStartTime' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, ReloadFullCharacterAnimation) == 0x0004B8, "Member 'AItem_Gun_General::ReloadFullCharacterAnimation' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, ReloadFullCharacterAnimationAimingStartTime) == 0x0004C0, "Member 'AItem_Gun_General::ReloadFullCharacterAnimationAimingStartTime' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, ShotCharacterAnimation) == 0x0004C8, "Member 'AItem_Gun_General::ShotCharacterAnimation' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, EndShotCharacterAnimation) == 0x0004D0, "Member 'AItem_Gun_General::EndShotCharacterAnimation' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, BoltCharacterAnimation) == 0x0004D8, "Member 'AItem_Gun_General::BoltCharacterAnimation' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, GrenadeThrowAdditiveAnimation) == 0x0004E0, "Member 'AItem_Gun_General::GrenadeThrowAdditiveAnimation' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, EquipAnimation) == 0x0004E8, "Member 'AItem_Gun_General::EquipAnimation' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, AimingEquipAnimation) == 0x0004F0, "Member 'AItem_Gun_General::AimingEquipAnimation' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, HolsterAnimation) == 0x0004F8, "Member 'AItem_Gun_General::HolsterAnimation' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, AimingAnimation) == 0x000500, "Member 'AItem_Gun_General::AimingAnimation' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, ShotGunAnimation) == 0x000508, "Member 'AItem_Gun_General::ShotGunAnimation' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, BoltGunAnimation) == 0x000510, "Member 'AItem_Gun_General::BoltGunAnimation' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, ReloadGunAnimation) == 0x000518, "Member 'AItem_Gun_General::ReloadGunAnimation' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, ReloadFullGunAnimation) == 0x000520, "Member 'AItem_Gun_General::ReloadFullGunAnimation' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, NoAmmoGunAnimation) == 0x000528, "Member 'AItem_Gun_General::NoAmmoGunAnimation' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, FirstPersonGunPosition) == 0x000530, "Member 'AItem_Gun_General::FirstPersonGunPosition' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, ThirdPersonGunPosition) == 0x000548, "Member 'AItem_Gun_General::ThirdPersonGunPosition' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, LeftHandOffset) == 0x000560, "Member 'AItem_Gun_General::LeftHandOffset' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, SprintLiftGun) == 0x0005C0, "Member 'AItem_Gun_General::SprintLiftGun' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, WatchOffset) == 0x0005E0, "Member 'AItem_Gun_General::WatchOffset' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, SoundShot_FP) == 0x000640, "Member 'AItem_Gun_General::SoundShot_FP' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, SoundShot_TP) == 0x000670, "Member 'AItem_Gun_General::SoundShot_TP' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, SoundBlankShot) == 0x0006A0, "Member 'AItem_Gun_General::SoundBlankShot' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, SoundAiming) == 0x0006A8, "Member 'AItem_Gun_General::SoundAiming' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, CustomSounds) == 0x0006B0, "Member 'AItem_Gun_General::CustomSounds' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, CallHardReset) == 0x0006C0, "Member 'AItem_Gun_General::CallHardReset' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, CurrentMagazineAmmo) == 0x0006C4, "Member 'AItem_Gun_General::CurrentMagazineAmmo' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, CurrentStockAmmo) == 0x0006C8, "Member 'AItem_Gun_General::CurrentStockAmmo' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, ReloadCaller) == 0x0006CA, "Member 'AItem_Gun_General::ReloadCaller' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, PoolProjectiles) == 0x0006D0, "Member 'AItem_Gun_General::PoolProjectiles' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, PoolBulletCasings) == 0x0006E0, "Member 'AItem_Gun_General::PoolBulletCasings' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, CurrentSpread) == 0x0006F4, "Member 'AItem_Gun_General::CurrentSpread' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, CurrentGunModuleClasses) == 0x0006F8, "Member 'AItem_Gun_General::CurrentGunModuleClasses' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, CurrentGunModuleReferences) == 0x000708, "Member 'AItem_Gun_General::CurrentGunModuleReferences' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, GunShot) == 0x000718, "Member 'AItem_Gun_General::GunShot' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, GunHitOfShortShot) == 0x000738, "Member 'AItem_Gun_General::GunHitOfShortShot' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, ActiveSoundShot) == 0x000758, "Member 'AItem_Gun_General::ActiveSoundShot' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, ItemReference) == 0x000760, "Member 'AItem_Gun_General::ItemReference' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, GunMesh) == 0x000768, "Member 'AItem_Gun_General::GunMesh' has a wrong offset!");
static_assert(offsetof(AItem_Gun_General, Magazine) == 0x000770, "Member 'AItem_Gun_General::Magazine' has a wrong offset!");

// Class POLYGON.Item_Gun_Pistol
// 0x0000 (0x0780 - 0x0780)
class AItem_Gun_Pistol : public AItem_Gun_General
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Item_Gun_Pistol">();
	}
	static class AItem_Gun_Pistol* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItem_Gun_Pistol>();
	}
};
static_assert(alignof(AItem_Gun_Pistol) == 0x000010, "Wrong alignment on AItem_Gun_Pistol");
static_assert(sizeof(AItem_Gun_Pistol) == 0x000780, "Wrong size on AItem_Gun_Pistol");

// Class POLYGON.Item_Gun_Rifle
// 0x0000 (0x0780 - 0x0780)
class AItem_Gun_Rifle : public AItem_Gun_General
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Item_Gun_Rifle">();
	}
	static class AItem_Gun_Rifle* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItem_Gun_Rifle>();
	}
};
static_assert(alignof(AItem_Gun_Rifle) == 0x000010, "Wrong alignment on AItem_Gun_Rifle");
static_assert(sizeof(AItem_Gun_Rifle) == 0x000780, "Wrong size on AItem_Gun_Rifle");

// Class POLYGON.Item_Gun_Sniper
// 0x0000 (0x0780 - 0x0780)
class AItem_Gun_Sniper : public AItem_Gun_General
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Item_Gun_Sniper">();
	}
	static class AItem_Gun_Sniper* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItem_Gun_Sniper>();
	}
};
static_assert(alignof(AItem_Gun_Sniper) == 0x000010, "Wrong alignment on AItem_Gun_Sniper");
static_assert(sizeof(AItem_Gun_Sniper) == 0x000780, "Wrong size on AItem_Gun_Sniper");

// Class POLYGON.Item_Module_General
// 0x0048 (0x0340 - 0x02F8)
class AItem_Module_General : public AItem_General
{
public:
	uint8                                         Pad_2C48[0x8];                                     // 0x02F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EGunModuleType                                GunModuleType;                                     // 0x0300(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C49[0x7];                                     // 0x0301(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              ModuleWhiteIcon;                                   // 0x0308(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsDefault;                                        // 0x0338(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C4A[0x7];                                     // 0x0339(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Item_Module_General">();
	}
	static class AItem_Module_General* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItem_Module_General>();
	}
};
static_assert(alignof(AItem_Module_General) == 0x000008, "Wrong alignment on AItem_Module_General");
static_assert(sizeof(AItem_Module_General) == 0x000340, "Wrong size on AItem_Module_General");
static_assert(offsetof(AItem_Module_General, GunModuleType) == 0x000300, "Member 'AItem_Module_General::GunModuleType' has a wrong offset!");
static_assert(offsetof(AItem_Module_General, ModuleWhiteIcon) == 0x000308, "Member 'AItem_Module_General::ModuleWhiteIcon' has a wrong offset!");
static_assert(offsetof(AItem_Module_General, bIsDefault) == 0x000338, "Member 'AItem_Module_General::bIsDefault' has a wrong offset!");

// Class POLYGON.Item_Module_Accessory
// 0x0010 (0x0350 - 0x0340)
class AItem_Module_Accessory : public AItem_Module_General
{
public:
	class FName                                   MountingSocket;                                    // 0x0340(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   ModuleMesh;                                        // 0x0348(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Item_Module_Accessory">();
	}
	static class AItem_Module_Accessory* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItem_Module_Accessory>();
	}
};
static_assert(alignof(AItem_Module_Accessory) == 0x000008, "Wrong alignment on AItem_Module_Accessory");
static_assert(sizeof(AItem_Module_Accessory) == 0x000350, "Wrong size on AItem_Module_Accessory");
static_assert(offsetof(AItem_Module_Accessory, MountingSocket) == 0x000340, "Member 'AItem_Module_Accessory::MountingSocket' has a wrong offset!");
static_assert(offsetof(AItem_Module_Accessory, ModuleMesh) == 0x000348, "Member 'AItem_Module_Accessory::ModuleMesh' has a wrong offset!");

// Class POLYGON.Item_Module_Barrel
// 0x0008 (0x0348 - 0x0340)
class AItem_Module_Barrel : public AItem_Module_General
{
public:
	class UStaticMeshComponent*                   ModuleMesh;                                        // 0x0340(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Item_Module_Barrel">();
	}
	static class AItem_Module_Barrel* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItem_Module_Barrel>();
	}
};
static_assert(alignof(AItem_Module_Barrel) == 0x000008, "Wrong alignment on AItem_Module_Barrel");
static_assert(sizeof(AItem_Module_Barrel) == 0x000348, "Wrong size on AItem_Module_Barrel");
static_assert(offsetof(AItem_Module_Barrel, ModuleMesh) == 0x000340, "Member 'AItem_Module_Barrel::ModuleMesh' has a wrong offset!");

// Class POLYGON.Item_Module_Flashlight
// 0x0018 (0x0368 - 0x0350)
class AItem_Module_Flashlight : public AItem_Module_Accessory
{
public:
	FMulticastInlineDelegateProperty_             OnEnable;                                          // 0x0350(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bIsEnable;                                         // 0x0360(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C4B[0x7];                                     // 0x0361(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnChangeEnableState(const bool bPlaySound);
	void OnRep_IsEnable(bool OldState);
	void OnSetCurrentGun(class AItem_Gun_General* PreviousGun);
	void SetFlashlightEnable(const bool IsEnable, bool bCallOnServer);
	void SetFlashlightEnable_server(const bool IsEnable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Item_Module_Flashlight">();
	}
	static class AItem_Module_Flashlight* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItem_Module_Flashlight>();
	}
};
static_assert(alignof(AItem_Module_Flashlight) == 0x000008, "Wrong alignment on AItem_Module_Flashlight");
static_assert(sizeof(AItem_Module_Flashlight) == 0x000368, "Wrong size on AItem_Module_Flashlight");
static_assert(offsetof(AItem_Module_Flashlight, OnEnable) == 0x000350, "Member 'AItem_Module_Flashlight::OnEnable' has a wrong offset!");
static_assert(offsetof(AItem_Module_Flashlight, bIsEnable) == 0x000360, "Member 'AItem_Module_Flashlight::bIsEnable' has a wrong offset!");

// Class POLYGON.Item_Module_Optic
// 0x0048 (0x0388 - 0x0340)
class AItem_Module_Optic : public AItem_Module_General
{
public:
	class FName                                   MountingSocket;                                    // 0x0340(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FOV;                                               // 0x0348(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StepsImpact;                                       // 0x034C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BackwardRecoilMultiplier;                          // 0x0350(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BlurPower;                                         // 0x0354(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BlurRadius;                                        // 0x0358(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BlurDensity;                                       // 0x035C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BlurBlackout;                                      // 0x0360(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsScope;                                          // 0x0364(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C4C[0x3];                                     // 0x0365(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            AimingMesh;                                        // 0x0368(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ActivateAimingMeshFovAlpha;                        // 0x0370(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DeactivateAimingMeshFovAlpha;                      // 0x0374(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstance*                      AimingMaterial;                                    // 0x0378(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   ModuleMesh;                                        // 0x0380(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ToggleAiming(const bool IsAiming);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Item_Module_Optic">();
	}
	static class AItem_Module_Optic* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItem_Module_Optic>();
	}
};
static_assert(alignof(AItem_Module_Optic) == 0x000008, "Wrong alignment on AItem_Module_Optic");
static_assert(sizeof(AItem_Module_Optic) == 0x000388, "Wrong size on AItem_Module_Optic");
static_assert(offsetof(AItem_Module_Optic, MountingSocket) == 0x000340, "Member 'AItem_Module_Optic::MountingSocket' has a wrong offset!");
static_assert(offsetof(AItem_Module_Optic, FOV) == 0x000348, "Member 'AItem_Module_Optic::FOV' has a wrong offset!");
static_assert(offsetof(AItem_Module_Optic, StepsImpact) == 0x00034C, "Member 'AItem_Module_Optic::StepsImpact' has a wrong offset!");
static_assert(offsetof(AItem_Module_Optic, BackwardRecoilMultiplier) == 0x000350, "Member 'AItem_Module_Optic::BackwardRecoilMultiplier' has a wrong offset!");
static_assert(offsetof(AItem_Module_Optic, BlurPower) == 0x000354, "Member 'AItem_Module_Optic::BlurPower' has a wrong offset!");
static_assert(offsetof(AItem_Module_Optic, BlurRadius) == 0x000358, "Member 'AItem_Module_Optic::BlurRadius' has a wrong offset!");
static_assert(offsetof(AItem_Module_Optic, BlurDensity) == 0x00035C, "Member 'AItem_Module_Optic::BlurDensity' has a wrong offset!");
static_assert(offsetof(AItem_Module_Optic, BlurBlackout) == 0x000360, "Member 'AItem_Module_Optic::BlurBlackout' has a wrong offset!");
static_assert(offsetof(AItem_Module_Optic, bIsScope) == 0x000364, "Member 'AItem_Module_Optic::bIsScope' has a wrong offset!");
static_assert(offsetof(AItem_Module_Optic, AimingMesh) == 0x000368, "Member 'AItem_Module_Optic::AimingMesh' has a wrong offset!");
static_assert(offsetof(AItem_Module_Optic, ActivateAimingMeshFovAlpha) == 0x000370, "Member 'AItem_Module_Optic::ActivateAimingMeshFovAlpha' has a wrong offset!");
static_assert(offsetof(AItem_Module_Optic, DeactivateAimingMeshFovAlpha) == 0x000374, "Member 'AItem_Module_Optic::DeactivateAimingMeshFovAlpha' has a wrong offset!");
static_assert(offsetof(AItem_Module_Optic, AimingMaterial) == 0x000378, "Member 'AItem_Module_Optic::AimingMaterial' has a wrong offset!");
static_assert(offsetof(AItem_Module_Optic, ModuleMesh) == 0x000380, "Member 'AItem_Module_Optic::ModuleMesh' has a wrong offset!");

// Class POLYGON.Item_Module_Skin
// 0x0018 (0x0358 - 0x0340)
class AItem_Module_Skin : public AItem_Module_General
{
public:
	EItemRareType                                 Rare;                                              // 0x0340(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C4D[0x7];                                     // 0x0341(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstance*                      SkinMaterial;                                      // 0x0348(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstance*                      SkinMaterialCorrectFOV;                            // 0x0350(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Item_Module_Skin">();
	}
	static class AItem_Module_Skin* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItem_Module_Skin>();
	}
};
static_assert(alignof(AItem_Module_Skin) == 0x000008, "Wrong alignment on AItem_Module_Skin");
static_assert(sizeof(AItem_Module_Skin) == 0x000358, "Wrong size on AItem_Module_Skin");
static_assert(offsetof(AItem_Module_Skin, Rare) == 0x000340, "Member 'AItem_Module_Skin::Rare' has a wrong offset!");
static_assert(offsetof(AItem_Module_Skin, SkinMaterial) == 0x000348, "Member 'AItem_Module_Skin::SkinMaterial' has a wrong offset!");
static_assert(offsetof(AItem_Module_Skin, SkinMaterialCorrectFOV) == 0x000350, "Member 'AItem_Module_Skin::SkinMaterialCorrectFOV' has a wrong offset!");

// Class POLYGON.Item_Module_Strap
// 0x0010 (0x0350 - 0x0340)
class AItem_Module_Strap : public AItem_Module_General
{
public:
	EItemRareType                                 Rare;                                              // 0x0340(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C4E[0x7];                                     // 0x0341(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   ModuleMesh;                                        // 0x0348(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Item_Module_Strap">();
	}
	static class AItem_Module_Strap* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItem_Module_Strap>();
	}
};
static_assert(alignof(AItem_Module_Strap) == 0x000008, "Wrong alignment on AItem_Module_Strap");
static_assert(sizeof(AItem_Module_Strap) == 0x000350, "Wrong size on AItem_Module_Strap");
static_assert(offsetof(AItem_Module_Strap, Rare) == 0x000340, "Member 'AItem_Module_Strap::Rare' has a wrong offset!");
static_assert(offsetof(AItem_Module_Strap, ModuleMesh) == 0x000348, "Member 'AItem_Module_Strap::ModuleMesh' has a wrong offset!");

// Class POLYGON.Item_Module_Underbarrel
// 0x0008 (0x0348 - 0x0340)
class AItem_Module_Underbarrel : public AItem_Module_General
{
public:
	class UStaticMeshComponent*                   ModuleMesh;                                        // 0x0340(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Item_Module_Underbarrel">();
	}
	static class AItem_Module_Underbarrel* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItem_Module_Underbarrel>();
	}
};
static_assert(alignof(AItem_Module_Underbarrel) == 0x000008, "Wrong alignment on AItem_Module_Underbarrel");
static_assert(sizeof(AItem_Module_Underbarrel) == 0x000348, "Wrong size on AItem_Module_Underbarrel");
static_assert(offsetof(AItem_Module_Underbarrel, ModuleMesh) == 0x000340, "Member 'AItem_Module_Underbarrel::ModuleMesh' has a wrong offset!");

// Class POLYGON.Item_Module_Underbarrel_Grip
// 0x0078 (0x03C0 - 0x0348)
class AItem_Module_Underbarrel_Grip : public AItem_Module_Underbarrel
{
public:
	uint8                                         Pad_2C4F[0x8];                                     // 0x0348(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             WatchOffset;                                       // 0x0350(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GripHandPose;                                      // 0x03B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C50[0x8];                                     // 0x03B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Item_Module_Underbarrel_Grip">();
	}
	static class AItem_Module_Underbarrel_Grip* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItem_Module_Underbarrel_Grip>();
	}
};
static_assert(alignof(AItem_Module_Underbarrel_Grip) == 0x000010, "Wrong alignment on AItem_Module_Underbarrel_Grip");
static_assert(sizeof(AItem_Module_Underbarrel_Grip) == 0x0003C0, "Wrong size on AItem_Module_Underbarrel_Grip");
static_assert(offsetof(AItem_Module_Underbarrel_Grip, WatchOffset) == 0x000350, "Member 'AItem_Module_Underbarrel_Grip::WatchOffset' has a wrong offset!");
static_assert(offsetof(AItem_Module_Underbarrel_Grip, GripHandPose) == 0x0003B0, "Member 'AItem_Module_Underbarrel_Grip::GripHandPose' has a wrong offset!");

// Class POLYGON.Item_Watch_General
// 0x0018 (0x0310 - 0x02F8)
class AItem_Watch_General : public AItem_General
{
public:
	uint8                                         Pad_2C51[0x8];                                     // 0x02F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EItemRareType                                 Rare;                                              // 0x0300(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C52[0x7];                                     // 0x0301(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   WatchMesh;                                         // 0x0308(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Item_Watch_General">();
	}
	static class AItem_Watch_General* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItem_Watch_General>();
	}
};
static_assert(alignof(AItem_Watch_General) == 0x000008, "Wrong alignment on AItem_Watch_General");
static_assert(sizeof(AItem_Watch_General) == 0x000310, "Wrong size on AItem_Watch_General");
static_assert(offsetof(AItem_Watch_General, Rare) == 0x000300, "Member 'AItem_Watch_General::Rare' has a wrong offset!");
static_assert(offsetof(AItem_Watch_General, WatchMesh) == 0x000308, "Member 'AItem_Watch_General::WatchMesh' has a wrong offset!");

// Class POLYGON.PG_AnimInstance
// 0x0000 (0x0350 - 0x0350)
class UPG_AnimInstance final : public UAnimInstance
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PG_AnimInstance">();
	}
	static class UPG_AnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPG_AnimInstance>();
	}
};
static_assert(alignof(UPG_AnimInstance) == 0x000010, "Wrong alignment on UPG_AnimInstance");
static_assert(sizeof(UPG_AnimInstance) == 0x000350, "Wrong size on UPG_AnimInstance");

// Class POLYGON.PG_CharacterMovementComponent
// 0x0000 (0x0F00 - 0x0F00)
class UPG_CharacterMovementComponent final : public UCharacterMovementComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PG_CharacterMovementComponent">();
	}
	static class UPG_CharacterMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPG_CharacterMovementComponent>();
	}
};
static_assert(alignof(UPG_CharacterMovementComponent) == 0x000010, "Wrong alignment on UPG_CharacterMovementComponent");
static_assert(sizeof(UPG_CharacterMovementComponent) == 0x000F00, "Wrong size on UPG_CharacterMovementComponent");

// Class POLYGON.PG_FunctionLibraryKit
// 0x0000 (0x0028 - 0x0028)
class UPG_FunctionLibraryKit final : public UBlueprintFunctionLibrary
{
public:
	static void ConfigureGameAnalyticsUserId(const class FString& UserId);
	static void ExitGame();
	static int32 GetBuildNumber();
	static class FString GetProjectVersion();
	static float GetRateScale(const class UAnimSequenceBase* AnimationSequenceBase);
	static EAzureRegion GetRegionEnum(const class FString& RegionName);
	static class FString ParseOption(const class FString& Options, const class FString& Key, const class FString& Separator);
	static void StartSessionGameAnalytics();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PG_FunctionLibraryKit">();
	}
	static class UPG_FunctionLibraryKit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPG_FunctionLibraryKit>();
	}
};
static_assert(alignof(UPG_FunctionLibraryKit) == 0x000008, "Wrong alignment on UPG_FunctionLibraryKit");
static_assert(sizeof(UPG_FunctionLibraryKit) == 0x000028, "Wrong size on UPG_FunctionLibraryKit");

// Class POLYGON.PG_GameInstance
// 0x0010 (0x01D0 - 0x01C0)
class UPG_GameInstance : public UGameInstance
{
public:
	class UServerGameInstance*                    ServerGameInstance;                                // 0x01C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UClientGameInstance*                    ClientGameInstance;                                // 0x01C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UClientGameInstance* GetClientGameInstance() const;
	class UServerGameInstance* GetServerGameInstance() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PG_GameInstance">();
	}
	static class UPG_GameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPG_GameInstance>();
	}
};
static_assert(alignof(UPG_GameInstance) == 0x000008, "Wrong alignment on UPG_GameInstance");
static_assert(sizeof(UPG_GameInstance) == 0x0001D0, "Wrong size on UPG_GameInstance");
static_assert(offsetof(UPG_GameInstance, ServerGameInstance) == 0x0001C0, "Member 'UPG_GameInstance::ServerGameInstance' has a wrong offset!");
static_assert(offsetof(UPG_GameInstance, ClientGameInstance) == 0x0001C8, "Member 'UPG_GameInstance::ClientGameInstance' has a wrong offset!");

// Class POLYGON.PG_GameMode_Base
// 0x0000 (0x0378 - 0x0378)
class APG_GameMode_Base : public AGameMode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PG_GameMode_Base">();
	}
	static class APG_GameMode_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<APG_GameMode_Base>();
	}
};
static_assert(alignof(APG_GameMode_Base) == 0x000008, "Wrong alignment on APG_GameMode_Base");
static_assert(sizeof(APG_GameMode_Base) == 0x000378, "Wrong size on APG_GameMode_Base");

// Class POLYGON.PG_GameMode_Game
// 0x0060 (0x03D8 - 0x0378)
class APG_GameMode_Game : public APG_GameMode_Base
{
public:
	class AOnlineBeaconHost*                      Beacon;                                            // 0x0378(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FBeaconSlotRequest>             PlayersQueue;                                      // 0x0380(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UReservedSlot*>                  ReservedSlots;                                     // 0x0390(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class FString>                         BlackListPlayersID;                                // 0x03A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C55[0x10];                                    // 0x03B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TotalGameTime;                                     // 0x03C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C56[0x4];                                     // 0x03C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPlayFabJsonObject*                     ServerData;                                        // 0x03C8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UServerBackendComponent*                ServerBackendComponent;                            // 0x03D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void LoginPlayer(class APG_PlayerController_Game* PlayerController, const class FString& PlayerMasterId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PG_GameMode_Game">();
	}
	static class APG_GameMode_Game* GetDefaultObj()
	{
		return GetDefaultObjImpl<APG_GameMode_Game>();
	}
};
static_assert(alignof(APG_GameMode_Game) == 0x000008, "Wrong alignment on APG_GameMode_Game");
static_assert(sizeof(APG_GameMode_Game) == 0x0003D8, "Wrong size on APG_GameMode_Game");
static_assert(offsetof(APG_GameMode_Game, Beacon) == 0x000378, "Member 'APG_GameMode_Game::Beacon' has a wrong offset!");
static_assert(offsetof(APG_GameMode_Game, PlayersQueue) == 0x000380, "Member 'APG_GameMode_Game::PlayersQueue' has a wrong offset!");
static_assert(offsetof(APG_GameMode_Game, ReservedSlots) == 0x000390, "Member 'APG_GameMode_Game::ReservedSlots' has a wrong offset!");
static_assert(offsetof(APG_GameMode_Game, BlackListPlayersID) == 0x0003A0, "Member 'APG_GameMode_Game::BlackListPlayersID' has a wrong offset!");
static_assert(offsetof(APG_GameMode_Game, TotalGameTime) == 0x0003C0, "Member 'APG_GameMode_Game::TotalGameTime' has a wrong offset!");
static_assert(offsetof(APG_GameMode_Game, ServerData) == 0x0003C8, "Member 'APG_GameMode_Game::ServerData' has a wrong offset!");
static_assert(offsetof(APG_GameMode_Game, ServerBackendComponent) == 0x0003D0, "Member 'APG_GameMode_Game::ServerBackendComponent' has a wrong offset!");

// Class POLYGON.PG_GameMode_Game_StandBy
// 0x0000 (0x0378 - 0x0378)
class APG_GameMode_Game_StandBy final : public AGameMode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PG_GameMode_Game_StandBy">();
	}
	static class APG_GameMode_Game_StandBy* GetDefaultObj()
	{
		return GetDefaultObjImpl<APG_GameMode_Game_StandBy>();
	}
};
static_assert(alignof(APG_GameMode_Game_StandBy) == 0x000008, "Wrong alignment on APG_GameMode_Game_StandBy");
static_assert(sizeof(APG_GameMode_Game_StandBy) == 0x000378, "Wrong size on APG_GameMode_Game_StandBy");

// Class POLYGON.PG_GameMode_Menu
// 0x0000 (0x0378 - 0x0378)
class APG_GameMode_Menu : public APG_GameMode_Base
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PG_GameMode_Menu">();
	}
	static class APG_GameMode_Menu* GetDefaultObj()
	{
		return GetDefaultObjImpl<APG_GameMode_Menu>();
	}
};
static_assert(alignof(APG_GameMode_Menu) == 0x000008, "Wrong alignment on APG_GameMode_Menu");
static_assert(sizeof(APG_GameMode_Menu) == 0x000378, "Wrong size on APG_GameMode_Menu");

// Class POLYGON.PG_GameState_Game
// 0x01F8 (0x0500 - 0x0308)
class APG_GameState_Game : public AGameState
{
public:
	FMulticastInlineDelegateProperty_             OnChangeGameState;                                 // 0x0308(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnGameTimer;                                       // 0x0318(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCanMovePlayers;                                  // 0x0328(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTeamWon;                                         // 0x0338(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangePlayersArray;                              // 0x0348(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeTeamAlphaArray;                            // 0x0358(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeTeamBravoArray;                            // 0x0368(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeTotalScore;                                // 0x0378(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnServerFps;                                       // 0x0388(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EPG_GameState                                 GameState;                                         // 0x0398(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C57[0x7];                                     // 0x0399(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMapInfo                               CurrentMapInfo;                                    // 0x03A0(0x00E8)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPrivate)
	uint16                                        GameTimer;                                         // 0x0488(0x0002)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCanMovePlayers;                                   // 0x048A(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETeam                                         WinningTeam;                                       // 0x048B(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C58[0x4];                                     // 0x048C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class APG_PlayerState_Game*>           Players;                                           // 0x0490(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	TArray<class APG_PlayerState_Game*>           TeamAlpha;                                         // 0x04A0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	TArray<class APG_PlayerState_Game*>           TeamBravo;                                         // 0x04B0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	TArray<class ATeamBase*>                      AllTeamBases;                                      // 0x04C0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class AControlPoint*>                  AllControlPoints;                                  // 0x04D0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class APlayerStart*>                   PlayerStarts;                                      // 0x04E0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint16                                        ScoreAlphaTeam;                                    // 0x04F0(0x0002)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint16                                        ScoreBravoTeam;                                    // 0x04F2(0x0002)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C59[0x2];                                     // 0x04F4(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         ServerFps;                                         // 0x04F6(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C5A[0x9];                                     // 0x04F7(0x0009)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NotifyPlayerWasKicked(const class FString& badGuyName, const bool bNameWasOptimized);
	void SetCanMovePlayers(const bool NewMoveState);

	int32 GetGameTimer() const;
	int32 GetMaxScoreForWin() const;
	int32 GetScoreAlphaTeam() const;
	int32 GetScoreBravoTeam() const;
	void OnRep_CanMovePlayers() const;
	void OnRep_GameState() const;
	void OnRep_GameTimer() const;
	void OnRep_Players() const;
	void OnRep_ScoreAlphaTeam() const;
	void OnRep_ScoreBravoTeam() const;
	void OnRep_ServerFps() const;
	void OnRep_TeamAlpha() const;
	void OnRep_TeamBravo() const;
	void OnRep_WinningTeam() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PG_GameState_Game">();
	}
	static class APG_GameState_Game* GetDefaultObj()
	{
		return GetDefaultObjImpl<APG_GameState_Game>();
	}
};
static_assert(alignof(APG_GameState_Game) == 0x000008, "Wrong alignment on APG_GameState_Game");
static_assert(sizeof(APG_GameState_Game) == 0x000500, "Wrong size on APG_GameState_Game");
static_assert(offsetof(APG_GameState_Game, OnChangeGameState) == 0x000308, "Member 'APG_GameState_Game::OnChangeGameState' has a wrong offset!");
static_assert(offsetof(APG_GameState_Game, OnGameTimer) == 0x000318, "Member 'APG_GameState_Game::OnGameTimer' has a wrong offset!");
static_assert(offsetof(APG_GameState_Game, OnCanMovePlayers) == 0x000328, "Member 'APG_GameState_Game::OnCanMovePlayers' has a wrong offset!");
static_assert(offsetof(APG_GameState_Game, OnTeamWon) == 0x000338, "Member 'APG_GameState_Game::OnTeamWon' has a wrong offset!");
static_assert(offsetof(APG_GameState_Game, OnChangePlayersArray) == 0x000348, "Member 'APG_GameState_Game::OnChangePlayersArray' has a wrong offset!");
static_assert(offsetof(APG_GameState_Game, OnChangeTeamAlphaArray) == 0x000358, "Member 'APG_GameState_Game::OnChangeTeamAlphaArray' has a wrong offset!");
static_assert(offsetof(APG_GameState_Game, OnChangeTeamBravoArray) == 0x000368, "Member 'APG_GameState_Game::OnChangeTeamBravoArray' has a wrong offset!");
static_assert(offsetof(APG_GameState_Game, OnChangeTotalScore) == 0x000378, "Member 'APG_GameState_Game::OnChangeTotalScore' has a wrong offset!");
static_assert(offsetof(APG_GameState_Game, OnServerFps) == 0x000388, "Member 'APG_GameState_Game::OnServerFps' has a wrong offset!");
static_assert(offsetof(APG_GameState_Game, GameState) == 0x000398, "Member 'APG_GameState_Game::GameState' has a wrong offset!");
static_assert(offsetof(APG_GameState_Game, CurrentMapInfo) == 0x0003A0, "Member 'APG_GameState_Game::CurrentMapInfo' has a wrong offset!");
static_assert(offsetof(APG_GameState_Game, GameTimer) == 0x000488, "Member 'APG_GameState_Game::GameTimer' has a wrong offset!");
static_assert(offsetof(APG_GameState_Game, bCanMovePlayers) == 0x00048A, "Member 'APG_GameState_Game::bCanMovePlayers' has a wrong offset!");
static_assert(offsetof(APG_GameState_Game, WinningTeam) == 0x00048B, "Member 'APG_GameState_Game::WinningTeam' has a wrong offset!");
static_assert(offsetof(APG_GameState_Game, Players) == 0x000490, "Member 'APG_GameState_Game::Players' has a wrong offset!");
static_assert(offsetof(APG_GameState_Game, TeamAlpha) == 0x0004A0, "Member 'APG_GameState_Game::TeamAlpha' has a wrong offset!");
static_assert(offsetof(APG_GameState_Game, TeamBravo) == 0x0004B0, "Member 'APG_GameState_Game::TeamBravo' has a wrong offset!");
static_assert(offsetof(APG_GameState_Game, AllTeamBases) == 0x0004C0, "Member 'APG_GameState_Game::AllTeamBases' has a wrong offset!");
static_assert(offsetof(APG_GameState_Game, AllControlPoints) == 0x0004D0, "Member 'APG_GameState_Game::AllControlPoints' has a wrong offset!");
static_assert(offsetof(APG_GameState_Game, PlayerStarts) == 0x0004E0, "Member 'APG_GameState_Game::PlayerStarts' has a wrong offset!");
static_assert(offsetof(APG_GameState_Game, ScoreAlphaTeam) == 0x0004F0, "Member 'APG_GameState_Game::ScoreAlphaTeam' has a wrong offset!");
static_assert(offsetof(APG_GameState_Game, ScoreBravoTeam) == 0x0004F2, "Member 'APG_GameState_Game::ScoreBravoTeam' has a wrong offset!");
static_assert(offsetof(APG_GameState_Game, ServerFps) == 0x0004F6, "Member 'APG_GameState_Game::ServerFps' has a wrong offset!");

// Class POLYGON.PG_Game_Character
// 0x0110 (0x0740 - 0x0630)
class APG_Game_Character : public ACharacter
{
public:
	uint8                                         Pad_2C5C[0x18];                                    // 0x0628(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnSetPlayerState;                                  // 0x0640(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSetActorHiddenInGame;                            // 0x0650(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C5D[0x1];                                     // 0x0660(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	EPlayerAction                                 PlayerAction;                                      // 0x0661(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C5E[0x2];                                     // 0x0662(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LeanBodyAlpha;                                     // 0x0664(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         RespawnCounter;                                    // 0x0668(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C5F[0xB];                                     // 0x0669(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ControllerPitchRotation;                           // 0x0674(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ControllerYawRotation;                             // 0x0678(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C60[0xC];                                     // 0x067C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 FocusActor;                                        // 0x0688(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C61[0x8];                                     // 0x0690(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 CurrentInteractActor;                              // 0x0698(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C62[0x8];                                     // 0x06A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        ParticleDamageBlood;                               // 0x06A8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             SoundBullet;                                       // 0x06B0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAnimInstance>              FirstPersonAnimInstanceClass;                      // 0x06B8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMesh*                          FirstPersonCharacterMesh;                          // 0x06C0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMesh*                          ThirdPersonCharacterMesh;                          // 0x06C8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UArrowComponent*                        ViewArrow;                                         // 0x06D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCameraComponent*                       FirstPersonCamera;                                 // 0x06D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpringArmComponent*                    ThirdPersonCameraBoom;                             // 0x06E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCameraComponent*                       ThirdPersonCamera;                                 // 0x06E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputComponent*                        PlayerInputComponent;                              // 0x06F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetComponent*                       WidgetPlayerMarker;                                // 0x06F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpringArmComponent*                    SpectatorCameraBoom;                               // 0x0700(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneCaptureComponent2D*               SpectatorCameraCapture;                            // 0x0708(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 Armor;                                             // 0x0710(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   HeadGear;                                          // 0x0718(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   Backpack;                                          // 0x0720(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AItem_Watch_General*                    Watch;                                             // 0x0728(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHealthStatsComponent*                  HealthStatsComponent;                              // 0x0730(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWeaponComponent*                       WeaponComponent;                                   // 0x0738(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ActionWhenGunHit_client(class APG_Game_Character* CharacterInstigator, const uint8 HitBoneIndex);
	void ActionWhenTakeDamage_client(class AActor* DamageCauser);
	void CameraNeutralizationEffectEvent(const float Damage);
	void ChangeIsAlive();
	void DeathEvent(class APG_PlayerState_Game* Killer, EPlayerDeathType DeathType);
	void EventTakeDamage(const struct FVector& Origin);
	void HitAtProtectedCharacter();
	void LeanBody_server(const int8 Param_LeanBodyAlpha);
	void NotifyDeath_multicast(class APG_PlayerState_Game* Killer, EPlayerDeathType DeathType);
	void NotifyDeathWithImpulse_multicast(class APG_PlayerState_Game* Killer, EPlayerDeathType DeathType, const struct FVector_NetQuantize& Impulse, const uint8& BoneIndex);
	void OnRep_PlayerAction(EPlayerAction PreviousAction);
	void OnRep_RespawnCounter(uint8 PreviousValue);
	void PlayerLooks();
	void Respawn();
	void Respawn_client(const struct FVector_NetQuantize& NewLocation, const struct FVector_NetQuantizeNormal& NewRotator);
	void SetIsSprinting_server(const bool NewState);
	void SetNeutralizationVignetteImpact(const float NewNeutralizationVignetteImpact);
	void StartInteractWithObject();
	void StartInteractWithObject_server(class AActor* InteractActor);
	void StartShooting();
	void StopInteractWithObject();
	void StopInteractWithObject_server();

	class UCameraComponent* GetActiveCamera() const;
	bool GetIsSprinting() const;
	float GetNeutralizationVignetteImpact() const;
	EPlayerAction GetPlayerAction() const;
	ETeam GetTeam() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PG_Game_Character">();
	}
	static class APG_Game_Character* GetDefaultObj()
	{
		return GetDefaultObjImpl<APG_Game_Character>();
	}
};
static_assert(alignof(APG_Game_Character) == 0x000010, "Wrong alignment on APG_Game_Character");
static_assert(sizeof(APG_Game_Character) == 0x000740, "Wrong size on APG_Game_Character");
static_assert(offsetof(APG_Game_Character, OnSetPlayerState) == 0x000640, "Member 'APG_Game_Character::OnSetPlayerState' has a wrong offset!");
static_assert(offsetof(APG_Game_Character, OnSetActorHiddenInGame) == 0x000650, "Member 'APG_Game_Character::OnSetActorHiddenInGame' has a wrong offset!");
static_assert(offsetof(APG_Game_Character, PlayerAction) == 0x000661, "Member 'APG_Game_Character::PlayerAction' has a wrong offset!");
static_assert(offsetof(APG_Game_Character, LeanBodyAlpha) == 0x000664, "Member 'APG_Game_Character::LeanBodyAlpha' has a wrong offset!");
static_assert(offsetof(APG_Game_Character, RespawnCounter) == 0x000668, "Member 'APG_Game_Character::RespawnCounter' has a wrong offset!");
static_assert(offsetof(APG_Game_Character, ControllerPitchRotation) == 0x000674, "Member 'APG_Game_Character::ControllerPitchRotation' has a wrong offset!");
static_assert(offsetof(APG_Game_Character, ControllerYawRotation) == 0x000678, "Member 'APG_Game_Character::ControllerYawRotation' has a wrong offset!");
static_assert(offsetof(APG_Game_Character, FocusActor) == 0x000688, "Member 'APG_Game_Character::FocusActor' has a wrong offset!");
static_assert(offsetof(APG_Game_Character, CurrentInteractActor) == 0x000698, "Member 'APG_Game_Character::CurrentInteractActor' has a wrong offset!");
static_assert(offsetof(APG_Game_Character, ParticleDamageBlood) == 0x0006A8, "Member 'APG_Game_Character::ParticleDamageBlood' has a wrong offset!");
static_assert(offsetof(APG_Game_Character, SoundBullet) == 0x0006B0, "Member 'APG_Game_Character::SoundBullet' has a wrong offset!");
static_assert(offsetof(APG_Game_Character, FirstPersonAnimInstanceClass) == 0x0006B8, "Member 'APG_Game_Character::FirstPersonAnimInstanceClass' has a wrong offset!");
static_assert(offsetof(APG_Game_Character, FirstPersonCharacterMesh) == 0x0006C0, "Member 'APG_Game_Character::FirstPersonCharacterMesh' has a wrong offset!");
static_assert(offsetof(APG_Game_Character, ThirdPersonCharacterMesh) == 0x0006C8, "Member 'APG_Game_Character::ThirdPersonCharacterMesh' has a wrong offset!");
static_assert(offsetof(APG_Game_Character, ViewArrow) == 0x0006D0, "Member 'APG_Game_Character::ViewArrow' has a wrong offset!");
static_assert(offsetof(APG_Game_Character, FirstPersonCamera) == 0x0006D8, "Member 'APG_Game_Character::FirstPersonCamera' has a wrong offset!");
static_assert(offsetof(APG_Game_Character, ThirdPersonCameraBoom) == 0x0006E0, "Member 'APG_Game_Character::ThirdPersonCameraBoom' has a wrong offset!");
static_assert(offsetof(APG_Game_Character, ThirdPersonCamera) == 0x0006E8, "Member 'APG_Game_Character::ThirdPersonCamera' has a wrong offset!");
static_assert(offsetof(APG_Game_Character, PlayerInputComponent) == 0x0006F0, "Member 'APG_Game_Character::PlayerInputComponent' has a wrong offset!");
static_assert(offsetof(APG_Game_Character, WidgetPlayerMarker) == 0x0006F8, "Member 'APG_Game_Character::WidgetPlayerMarker' has a wrong offset!");
static_assert(offsetof(APG_Game_Character, SpectatorCameraBoom) == 0x000700, "Member 'APG_Game_Character::SpectatorCameraBoom' has a wrong offset!");
static_assert(offsetof(APG_Game_Character, SpectatorCameraCapture) == 0x000708, "Member 'APG_Game_Character::SpectatorCameraCapture' has a wrong offset!");
static_assert(offsetof(APG_Game_Character, Armor) == 0x000710, "Member 'APG_Game_Character::Armor' has a wrong offset!");
static_assert(offsetof(APG_Game_Character, HeadGear) == 0x000718, "Member 'APG_Game_Character::HeadGear' has a wrong offset!");
static_assert(offsetof(APG_Game_Character, Backpack) == 0x000720, "Member 'APG_Game_Character::Backpack' has a wrong offset!");
static_assert(offsetof(APG_Game_Character, Watch) == 0x000728, "Member 'APG_Game_Character::Watch' has a wrong offset!");
static_assert(offsetof(APG_Game_Character, HealthStatsComponent) == 0x000730, "Member 'APG_Game_Character::HealthStatsComponent' has a wrong offset!");
static_assert(offsetof(APG_Game_Character, WeaponComponent) == 0x000738, "Member 'APG_Game_Character::WeaponComponent' has a wrong offset!");

// Class POLYGON.PG_Menu_Character
// 0x0028 (0x02B8 - 0x0290)
class APG_Menu_Character : public AActor
{
public:
	TWeakObjectPtr<class APG_Menu_Character>      Instance;                                          // 0x0290(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 Mesh;                                              // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 Armor;                                             // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   HeadGear;                                          // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   Backpack;                                          // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PG_Menu_Character">();
	}
	static class APG_Menu_Character* GetDefaultObj()
	{
		return GetDefaultObjImpl<APG_Menu_Character>();
	}
};
static_assert(alignof(APG_Menu_Character) == 0x000008, "Wrong alignment on APG_Menu_Character");
static_assert(sizeof(APG_Menu_Character) == 0x0002B8, "Wrong size on APG_Menu_Character");
static_assert(offsetof(APG_Menu_Character, Instance) == 0x000290, "Member 'APG_Menu_Character::Instance' has a wrong offset!");
static_assert(offsetof(APG_Menu_Character, Mesh) == 0x000298, "Member 'APG_Menu_Character::Mesh' has a wrong offset!");
static_assert(offsetof(APG_Menu_Character, Armor) == 0x0002A0, "Member 'APG_Menu_Character::Armor' has a wrong offset!");
static_assert(offsetof(APG_Menu_Character, HeadGear) == 0x0002A8, "Member 'APG_Menu_Character::HeadGear' has a wrong offset!");
static_assert(offsetof(APG_Menu_Character, Backpack) == 0x0002B0, "Member 'APG_Menu_Character::Backpack' has a wrong offset!");

// Class POLYGON.PG_BeaconHostObject
// 0x0000 (0x02B8 - 0x02B8)
class APG_BeaconHostObject final : public AOnlineBeaconHostObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PG_BeaconHostObject">();
	}
	static class APG_BeaconHostObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<APG_BeaconHostObject>();
	}
};
static_assert(alignof(APG_BeaconHostObject) == 0x000008, "Wrong alignment on APG_BeaconHostObject");
static_assert(sizeof(APG_BeaconHostObject) == 0x0002B8, "Wrong size on APG_BeaconHostObject");

// Class POLYGON.PG_BeaconClient
// 0x0030 (0x0350 - 0x0320)
class APG_BeaconClient final : public AOnlineBeaconClient
{
public:
	uint8                                         Pad_2C68[0x30];                                    // 0x0320(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ConnectToServer(const class FString& IP, const int32 BeaconPort, TDelegate<void(bool bWasSuccessful)> OnConnectedStateChange);
	void LeaveQueue();
	void RequestReserveSlot(const TArray<struct FUniqueNetIdRepl>& UnequeIds, const bool IsUsedMatchmaker, TDelegate<void(uint8 Payload)> OnResponseReserveSlot, TDelegate<void(uint8 Number)> OnPutInQueue);
	void RequestReserveSlot_server(const TArray<struct FUniqueNetIdRepl>& UnequeIds, const bool IsUsedMatchmaker);
	void ResponseReserveSlot_client(const uint8 Payload);
	void SendNumberInQueue_client(const uint8 Number);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PG_BeaconClient">();
	}
	static class APG_BeaconClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<APG_BeaconClient>();
	}
};
static_assert(alignof(APG_BeaconClient) == 0x000008, "Wrong alignment on APG_BeaconClient");
static_assert(sizeof(APG_BeaconClient) == 0x000350, "Wrong size on APG_BeaconClient");

// Class POLYGON.PG_PlayerController_Base
// 0x0038 (0x0888 - 0x0850)
class APG_PlayerController_Base : public APlayerController
{
public:
	FMulticastInlineDelegateProperty_             OnSetPlayerState;                                  // 0x0850(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnClientReset;                                     // 0x0860(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         AimMode;                                           // 0x0870(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CrouchMode;                                        // 0x0874(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         LeanMode;                                          // 0x0878(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SprintMode;                                        // 0x087C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSprintCancelReload;                               // 0x0880(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C6D[0x7];                                     // 0x0881(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static float GetMouseSensitivityAimingValue();
	static float GetMouseSensitivityValue();
	static bool IsInvertMouse();

	void ShowError(const class FText& ErrorMessage, const class FText& ErrorDetails);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PG_PlayerController_Base">();
	}
	static class APG_PlayerController_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<APG_PlayerController_Base>();
	}
};
static_assert(alignof(APG_PlayerController_Base) == 0x000008, "Wrong alignment on APG_PlayerController_Base");
static_assert(sizeof(APG_PlayerController_Base) == 0x000888, "Wrong size on APG_PlayerController_Base");
static_assert(offsetof(APG_PlayerController_Base, OnSetPlayerState) == 0x000850, "Member 'APG_PlayerController_Base::OnSetPlayerState' has a wrong offset!");
static_assert(offsetof(APG_PlayerController_Base, OnClientReset) == 0x000860, "Member 'APG_PlayerController_Base::OnClientReset' has a wrong offset!");
static_assert(offsetof(APG_PlayerController_Base, AimMode) == 0x000870, "Member 'APG_PlayerController_Base::AimMode' has a wrong offset!");
static_assert(offsetof(APG_PlayerController_Base, CrouchMode) == 0x000874, "Member 'APG_PlayerController_Base::CrouchMode' has a wrong offset!");
static_assert(offsetof(APG_PlayerController_Base, LeanMode) == 0x000878, "Member 'APG_PlayerController_Base::LeanMode' has a wrong offset!");
static_assert(offsetof(APG_PlayerController_Base, SprintMode) == 0x00087C, "Member 'APG_PlayerController_Base::SprintMode' has a wrong offset!");
static_assert(offsetof(APG_PlayerController_Base, bSprintCancelReload) == 0x000880, "Member 'APG_PlayerController_Base::bSprintCancelReload' has a wrong offset!");

// Class POLYGON.PG_PlayerController_Game
// 0x0030 (0x08B8 - 0x0888)
class APG_PlayerController_Game : public APG_PlayerController_Base
{
public:
	FMulticastInlineDelegateProperty_             OnDeployIsAvailable;                               // 0x0888(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         TimeVoteKick;                                      // 0x0898(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDeployIsAvailable;                                // 0x089C(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C6E[0xB];                                     // 0x089D(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	class UEventManagerComponent*                 EventManagerComponent;                             // 0x08A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFOVManagerComponent*                   FOVManagerComponent;                               // 0x08B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void DisplayMessageToChatEvent(const struct FGameChatMessage& Message);
	void LoginPlayer_server(const class FString& PlayerMasterId);
	void OnRep_DeployIsAvailable();
	void RequestSpawnOnBase_server();
	void RequestSpawnOnControlPoint_server(EControlPoint SpawnToControlPoint);
	void RequestSpawnOnSquadMember_server(class APG_PlayerState_Game* SquadMember);
	void SetVisibleLoadingScreen(const bool IsVisible);
	void StartInteraction_Client(const float InteractionTime);
	void StartInteractionEvent(const float InteractionTime);
	void StopInteraction_Client();
	void StopInteractionEvent();
	void VoteKick(class APG_PlayerState_Game* badGuy);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PG_PlayerController_Game">();
	}
	static class APG_PlayerController_Game* GetDefaultObj()
	{
		return GetDefaultObjImpl<APG_PlayerController_Game>();
	}
};
static_assert(alignof(APG_PlayerController_Game) == 0x000008, "Wrong alignment on APG_PlayerController_Game");
static_assert(sizeof(APG_PlayerController_Game) == 0x0008B8, "Wrong size on APG_PlayerController_Game");
static_assert(offsetof(APG_PlayerController_Game, OnDeployIsAvailable) == 0x000888, "Member 'APG_PlayerController_Game::OnDeployIsAvailable' has a wrong offset!");
static_assert(offsetof(APG_PlayerController_Game, TimeVoteKick) == 0x000898, "Member 'APG_PlayerController_Game::TimeVoteKick' has a wrong offset!");
static_assert(offsetof(APG_PlayerController_Game, bDeployIsAvailable) == 0x00089C, "Member 'APG_PlayerController_Game::bDeployIsAvailable' has a wrong offset!");
static_assert(offsetof(APG_PlayerController_Game, EventManagerComponent) == 0x0008A8, "Member 'APG_PlayerController_Game::EventManagerComponent' has a wrong offset!");
static_assert(offsetof(APG_PlayerController_Game, FOVManagerComponent) == 0x0008B0, "Member 'APG_PlayerController_Game::FOVManagerComponent' has a wrong offset!");

// Class POLYGON.PG_PlayerController_Menu
// 0x0000 (0x0888 - 0x0888)
class APG_PlayerController_Menu : public APG_PlayerController_Base
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PG_PlayerController_Menu">();
	}
	static class APG_PlayerController_Menu* GetDefaultObj()
	{
		return GetDefaultObjImpl<APG_PlayerController_Menu>();
	}
};
static_assert(alignof(APG_PlayerController_Menu) == 0x000008, "Wrong alignment on APG_PlayerController_Menu");
static_assert(sizeof(APG_PlayerController_Menu) == 0x000888, "Wrong size on APG_PlayerController_Menu");

// Class POLYGON.SupportBox
// 0x0028 (0x02B8 - 0x0290)
class ASupportBox : public AActor
{
public:
	uint8                                         Pad_2C6F[0x8];                                     // 0x0290(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class APG_Game_Character*>             CoverageCharacters;                                // 0x0298(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   BoxMesh;                                           // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetComponent*                       WidgetTypeSupportBox;                              // 0x02B0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnCoverageBeginOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool FromSweep, const struct FHitResult& SweepResult);
	void OnCoverageEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SupportBox">();
	}
	static class ASupportBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASupportBox>();
	}
};
static_assert(alignof(ASupportBox) == 0x000008, "Wrong alignment on ASupportBox");
static_assert(sizeof(ASupportBox) == 0x0002B8, "Wrong size on ASupportBox");
static_assert(offsetof(ASupportBox, CoverageCharacters) == 0x000298, "Member 'ASupportBox::CoverageCharacters' has a wrong offset!");
static_assert(offsetof(ASupportBox, BoxMesh) == 0x0002A8, "Member 'ASupportBox::BoxMesh' has a wrong offset!");
static_assert(offsetof(ASupportBox, WidgetTypeSupportBox) == 0x0002B0, "Member 'ASupportBox::WidgetTypeSupportBox' has a wrong offset!");

// Class POLYGON.SupportBox_Ammo
// 0x0008 (0x02C0 - 0x02B8)
class ASupportBox_Ammo : public ASupportBox
{
public:
	class USoundBase*                             ActionSound;                                       // 0x02B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SupportBox_Ammo">();
	}
	static class ASupportBox_Ammo* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASupportBox_Ammo>();
	}
};
static_assert(alignof(ASupportBox_Ammo) == 0x000008, "Wrong alignment on ASupportBox_Ammo");
static_assert(sizeof(ASupportBox_Ammo) == 0x0002C0, "Wrong size on ASupportBox_Ammo");
static_assert(offsetof(ASupportBox_Ammo, ActionSound) == 0x0002B8, "Member 'ASupportBox_Ammo::ActionSound' has a wrong offset!");

// Class POLYGON.SupportBox_Health
// 0x0000 (0x02B8 - 0x02B8)
class ASupportBox_Health final : public ASupportBox
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SupportBox_Health">();
	}
	static class ASupportBox_Health* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASupportBox_Health>();
	}
};
static_assert(alignof(ASupportBox_Health) == 0x000008, "Wrong alignment on ASupportBox_Health");
static_assert(sizeof(ASupportBox_Health) == 0x0002B8, "Wrong size on ASupportBox_Health");

// Class POLYGON.TeamBase
// 0x0008 (0x0298 - 0x0290)
class ATeamBase final : public AActor
{
public:
	ETeam                                         Team;                                              // 0x0290(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C72[0x7];                                     // 0x0291(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamBase">();
	}
	static class ATeamBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATeamBase>();
	}
};
static_assert(alignof(ATeamBase) == 0x000008, "Wrong alignment on ATeamBase");
static_assert(sizeof(ATeamBase) == 0x000298, "Wrong size on ATeamBase");
static_assert(offsetof(ATeamBase, Team) == 0x000290, "Member 'ATeamBase::Team' has a wrong offset!");

// Class POLYGON.UserEntry
// 0x0000 (0x0028 - 0x0028)
class UUserEntry : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserEntry">();
	}
	static class UUserEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserEntry>();
	}
};
static_assert(alignof(UUserEntry) == 0x000008, "Wrong alignment on UUserEntry");
static_assert(sizeof(UUserEntry) == 0x000028, "Wrong size on UUserEntry");

// Class POLYGON.WeaponComponent
// 0x00B0 (0x0150 - 0x00A0)
class UWeaponComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnAiming;                                          // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C73[0x1D];                                    // 0x00B0(0x001D)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsAiming;                                         // 0x00CD(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bGunIsDown;                                        // 0x00CE(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C74[0x1];                                     // 0x00CF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        FireFXLocal;                                       // 0x00D0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystem*                        FireFXSimulate;                                    // 0x00D8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystem*                        HitFX_Metal;                                       // 0x00E0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystem*                        HitFX_Stone;                                       // 0x00E8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystem*                        HitFX_Dirt;                                        // 0x00F0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystem*                        HitFX_Wood;                                        // 0x00F8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystem*                        HitFX_Water;                                       // 0x0100(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystem*                        HitFX_Glass;                                       // 0x0108(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystem*                        HitFX_Blood;                                       // 0x0110(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInterface*                     DecalImpact;                                       // 0x0118(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundBase*                             SoundCharacterHit;                                 // 0x0120(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundBase*                             SoundCharacterHit_Protection;                      // 0x0128(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundBase*                             SoundRicochetHit;                                  // 0x0130(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundBase*                             SoundBodyHit;                                      // 0x0138(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C75[0x10];                                    // 0x0140(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NotifyServerThrowGrenade();
	void OnRep_IsAiming();
	void OnSetCurrentGun(class AItem_Gun_General* OldCurrentGun);
	void OnSetPlayerState();
	void OnSetPrimaryGun(class AItem_Gun_General* OldGun);
	void OnSetSecondaryGun(class AItem_Gun_General* OldGun);
	void SelectGunSlot_server(const uint8 Slot);
	void SetGunRecoilAlpha_Roll(const float NewRollRecoil);
	void SetGunRecoilAlpha_Yaw(const float NewYawRecoil);
	void SetGunRecoilIsActive_Backward();
	void SetStrivingGunRecoilAlpha_Pitch(const float NewStrivingPitchRecoil);
	void SetWantsToAiming_server(const bool NewState);
	void ToggleAiming_server();

	class AItem_Gun_General* GetCurrentGun() const;
	float GetGunRecoilAlpha_Backward() const;
	float GetGunRecoilAlpha_Pitch() const;
	float GetGunRecoilAlpha_Roll() const;
	float GetGunRecoilAlpha_Yaw() const;
	bool GetIsShooting() const;
	bool IsAiming() const;
	bool IsWantsToAiming() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponComponent">();
	}
	static class UWeaponComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponComponent>();
	}
};
static_assert(alignof(UWeaponComponent) == 0x000008, "Wrong alignment on UWeaponComponent");
static_assert(sizeof(UWeaponComponent) == 0x000150, "Wrong size on UWeaponComponent");
static_assert(offsetof(UWeaponComponent, OnAiming) == 0x0000A0, "Member 'UWeaponComponent::OnAiming' has a wrong offset!");
static_assert(offsetof(UWeaponComponent, bIsAiming) == 0x0000CD, "Member 'UWeaponComponent::bIsAiming' has a wrong offset!");
static_assert(offsetof(UWeaponComponent, bGunIsDown) == 0x0000CE, "Member 'UWeaponComponent::bGunIsDown' has a wrong offset!");
static_assert(offsetof(UWeaponComponent, FireFXLocal) == 0x0000D0, "Member 'UWeaponComponent::FireFXLocal' has a wrong offset!");
static_assert(offsetof(UWeaponComponent, FireFXSimulate) == 0x0000D8, "Member 'UWeaponComponent::FireFXSimulate' has a wrong offset!");
static_assert(offsetof(UWeaponComponent, HitFX_Metal) == 0x0000E0, "Member 'UWeaponComponent::HitFX_Metal' has a wrong offset!");
static_assert(offsetof(UWeaponComponent, HitFX_Stone) == 0x0000E8, "Member 'UWeaponComponent::HitFX_Stone' has a wrong offset!");
static_assert(offsetof(UWeaponComponent, HitFX_Dirt) == 0x0000F0, "Member 'UWeaponComponent::HitFX_Dirt' has a wrong offset!");
static_assert(offsetof(UWeaponComponent, HitFX_Wood) == 0x0000F8, "Member 'UWeaponComponent::HitFX_Wood' has a wrong offset!");
static_assert(offsetof(UWeaponComponent, HitFX_Water) == 0x000100, "Member 'UWeaponComponent::HitFX_Water' has a wrong offset!");
static_assert(offsetof(UWeaponComponent, HitFX_Glass) == 0x000108, "Member 'UWeaponComponent::HitFX_Glass' has a wrong offset!");
static_assert(offsetof(UWeaponComponent, HitFX_Blood) == 0x000110, "Member 'UWeaponComponent::HitFX_Blood' has a wrong offset!");
static_assert(offsetof(UWeaponComponent, DecalImpact) == 0x000118, "Member 'UWeaponComponent::DecalImpact' has a wrong offset!");
static_assert(offsetof(UWeaponComponent, SoundCharacterHit) == 0x000120, "Member 'UWeaponComponent::SoundCharacterHit' has a wrong offset!");
static_assert(offsetof(UWeaponComponent, SoundCharacterHit_Protection) == 0x000128, "Member 'UWeaponComponent::SoundCharacterHit_Protection' has a wrong offset!");
static_assert(offsetof(UWeaponComponent, SoundRicochetHit) == 0x000130, "Member 'UWeaponComponent::SoundRicochetHit' has a wrong offset!");
static_assert(offsetof(UWeaponComponent, SoundBodyHit) == 0x000138, "Member 'UWeaponComponent::SoundBodyHit' has a wrong offset!");

}

