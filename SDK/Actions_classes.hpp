#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Actions

#include "Basic.hpp"

#include "Actions_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Engine_classes.hpp"
#include "AIModule_classes.hpp"


namespace SDK
{

// Class Actions.Action
// 0x0080 (0x00A8 - 0x0028)
class UAction : public UObject
{
public:
	bool                                          bWantsToTick;                                      // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FB1[0x3];                                     // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TickRate;                                          // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EActionState                                  State;                                             // 0x0030(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1FB2[0x7];                                     // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class UAction*>                          ChildrenActions;                                   // 0x0038(0x0050)(SaveGame, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnActivationDelegate;                              // 0x0088(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFinishedDelegate;                                // 0x0098(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)

public:
	void Activate();
	void Fail(class FName Error);
	void ReceiveActivate();
	bool ReceiveCanActivate();
	void ReceiveFinished(const EActionState Reason);
	void ReceiveTick(float DeltaTime);
	void Succeed();

	bool Failed() const;
	class UObject* GetOwner() const;
	class AActor* GetOwnerActor() const;
	class UActorComponent* GetOwnerComponent() const;
	const class UObject* GetParent() const;
	class UAction* GetParentAction() const;
	EActionState GetState() const;
	float GetTickRate() const;
	bool IsRunning() const;
	bool Succeeded() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Action">();
	}
	static class UAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAction>();
	}
};
static_assert(alignof(UAction) == 0x000008, "Wrong alignment on UAction");
static_assert(sizeof(UAction) == 0x0000A8, "Wrong size on UAction");
static_assert(offsetof(UAction, bWantsToTick) == 0x000028, "Member 'UAction::bWantsToTick' has a wrong offset!");
static_assert(offsetof(UAction, TickRate) == 0x00002C, "Member 'UAction::TickRate' has a wrong offset!");
static_assert(offsetof(UAction, State) == 0x000030, "Member 'UAction::State' has a wrong offset!");
static_assert(offsetof(UAction, ChildrenActions) == 0x000038, "Member 'UAction::ChildrenActions' has a wrong offset!");
static_assert(offsetof(UAction, OnActivationDelegate) == 0x000088, "Member 'UAction::OnActivationDelegate' has a wrong offset!");
static_assert(offsetof(UAction, OnFinishedDelegate) == 0x000098, "Member 'UAction::OnFinishedDelegate' has a wrong offset!");

// Class Actions.ActionLibrary
// 0x0000 (0x0028 - 0x0028)
class UActionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UAction* CreateAction(class UObject* Owner, const TSubclassOf<class UAction> Type, bool bAutoActivate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionLibrary">();
	}
	static class UActionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionLibrary>();
	}
};
static_assert(alignof(UActionLibrary) == 0x000008, "Wrong alignment on UActionLibrary");
static_assert(sizeof(UActionLibrary) == 0x000028, "Wrong size on UActionLibrary");

// Class Actions.ActionsSubsystem
// 0x0068 (0x0098 - 0x0030)
class UActionsSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_1FB4[0x8];                                     // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<struct FRootAction>                      RootActions;                                       // 0x0038(0x0050)(SaveGame, NativeAccessSpecifierPrivate)
	TArray<struct FActionsTickGroup>              TickGroups;                                        // 0x0088(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void CancelAllByClass(class UClass* ActionClass, const TArray<class UAction*>& IgnoreActions);
	void CancelAllByOwner(class UObject* Object);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionsSubsystem">();
	}
	static class UActionsSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionsSubsystem>();
	}
};
static_assert(alignof(UActionsSubsystem) == 0x000008, "Wrong alignment on UActionsSubsystem");
static_assert(sizeof(UActionsSubsystem) == 0x000098, "Wrong size on UActionsSubsystem");
static_assert(offsetof(UActionsSubsystem, RootActions) == 0x000038, "Member 'UActionsSubsystem::RootActions' has a wrong offset!");
static_assert(offsetof(UActionsSubsystem, TickGroups) == 0x000088, "Member 'UActionsSubsystem::TickGroups' has a wrong offset!");

// Class Actions.BTT_RunAction
// 0x0018 (0x0088 - 0x0070)
class UBTT_RunAction final : public UBTTaskNode
{
public:
	class UAction*                                ActionType;                                        // 0x0070(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAction*                                Action;                                            // 0x0078(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBehaviorTreeComponent*                 OwnerComp;                                         // 0x0080(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnRunActionFinished(const EActionState Reason);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTT_RunAction">();
	}
	static class UBTT_RunAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTT_RunAction>();
	}
};
static_assert(alignof(UBTT_RunAction) == 0x000008, "Wrong alignment on UBTT_RunAction");
static_assert(sizeof(UBTT_RunAction) == 0x000088, "Wrong size on UBTT_RunAction");
static_assert(offsetof(UBTT_RunAction, ActionType) == 0x000070, "Member 'UBTT_RunAction::ActionType' has a wrong offset!");
static_assert(offsetof(UBTT_RunAction, Action) == 0x000078, "Member 'UBTT_RunAction::Action' has a wrong offset!");
static_assert(offsetof(UBTT_RunAction, OwnerComp) == 0x000080, "Member 'UBTT_RunAction::OwnerComp' has a wrong offset!");

}

