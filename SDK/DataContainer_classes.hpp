#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DataContainer

#include "Basic.hpp"

#include "Engine_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"


namespace SDK
{

// Class DataContainer.DataContainerAsset
// 0x0008 (0x0038 - 0x0030)
class UDataContainerAsset final : public UDataAsset
{
public:
	class UDataContainerValue_DataObject*         Data;                                              // 0x0030(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DataContainerAsset">();
	}
	static class UDataContainerAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDataContainerAsset>();
	}
};
static_assert(alignof(UDataContainerAsset) == 0x000008, "Wrong alignment on UDataContainerAsset");
static_assert(sizeof(UDataContainerAsset) == 0x000038, "Wrong size on UDataContainerAsset");
static_assert(offsetof(UDataContainerAsset, Data) == 0x000030, "Member 'UDataContainerAsset::Data' has a wrong offset!");

// Class DataContainer.DataContainerValue_Base
// 0x0028 (0x0050 - 0x0028)
class UDataContainerValue_Base : public UObject
{
public:
	class FString                                 OptionalData;                                      // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DataType;                                          // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 Tooltip;                                           // 0x0040(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UDataContainerValue_Base* FindDataContainerValue(const class FString& TagPath);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DataContainerValue_Base">();
	}
	static class UDataContainerValue_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDataContainerValue_Base>();
	}
};
static_assert(alignof(UDataContainerValue_Base) == 0x000008, "Wrong alignment on UDataContainerValue_Base");
static_assert(sizeof(UDataContainerValue_Base) == 0x000050, "Wrong size on UDataContainerValue_Base");
static_assert(offsetof(UDataContainerValue_Base, OptionalData) == 0x000028, "Member 'UDataContainerValue_Base::OptionalData' has a wrong offset!");
static_assert(offsetof(UDataContainerValue_Base, DataType) == 0x000038, "Member 'UDataContainerValue_Base::DataType' has a wrong offset!");
static_assert(offsetof(UDataContainerValue_Base, Tooltip) == 0x000040, "Member 'UDataContainerValue_Base::Tooltip' has a wrong offset!");

// Class DataContainer.DataContainerValue_DataObject
// 0x0050 (0x00A0 - 0x0050)
class UDataContainerValue_DataObject final : public UDataContainerValue_Base
{
public:
	TMap<class FName, class UDataContainerValue_Base*> Values;                                            // 0x0050(0x0050)(Edit, BlueprintVisible, ExportObject, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DataContainerValue_DataObject">();
	}
	static class UDataContainerValue_DataObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDataContainerValue_DataObject>();
	}
};
static_assert(alignof(UDataContainerValue_DataObject) == 0x000008, "Wrong alignment on UDataContainerValue_DataObject");
static_assert(sizeof(UDataContainerValue_DataObject) == 0x0000A0, "Wrong size on UDataContainerValue_DataObject");
static_assert(offsetof(UDataContainerValue_DataObject, Values) == 0x000050, "Member 'UDataContainerValue_DataObject::Values' has a wrong offset!");

// Class DataContainer.DataContainerValue_DataObjectArray
// 0x0010 (0x0060 - 0x0050)
class UDataContainerValue_DataObjectArray final : public UDataContainerValue_Base
{
public:
	TArray<class UDataContainerValue_DataObject*> Data;                                              // 0x0050(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, ExposeOnSpawn, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DataContainerValue_DataObjectArray">();
	}
	static class UDataContainerValue_DataObjectArray* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDataContainerValue_DataObjectArray>();
	}
};
static_assert(alignof(UDataContainerValue_DataObjectArray) == 0x000008, "Wrong alignment on UDataContainerValue_DataObjectArray");
static_assert(sizeof(UDataContainerValue_DataObjectArray) == 0x000060, "Wrong size on UDataContainerValue_DataObjectArray");
static_assert(offsetof(UDataContainerValue_DataObjectArray, Data) == 0x000050, "Member 'UDataContainerValue_DataObjectArray::Data' has a wrong offset!");

// Class DataContainer.DataContainerValue_Bool
// 0x0008 (0x0058 - 0x0050)
class UDataContainerValue_Bool final : public UDataContainerValue_Base
{
public:
	bool                                          Data;                                              // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20C1[0x7];                                     // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DataContainerValue_Bool">();
	}
	static class UDataContainerValue_Bool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDataContainerValue_Bool>();
	}
};
static_assert(alignof(UDataContainerValue_Bool) == 0x000008, "Wrong alignment on UDataContainerValue_Bool");
static_assert(sizeof(UDataContainerValue_Bool) == 0x000058, "Wrong size on UDataContainerValue_Bool");
static_assert(offsetof(UDataContainerValue_Bool, Data) == 0x000050, "Member 'UDataContainerValue_Bool::Data' has a wrong offset!");

// Class DataContainer.DataContainerValue_BoolArray
// 0x0010 (0x0060 - 0x0050)
class UDataContainerValue_BoolArray final : public UDataContainerValue_Base
{
public:
	TArray<bool>                                  Data;                                              // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ExposeOnSpawn, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DataContainerValue_BoolArray">();
	}
	static class UDataContainerValue_BoolArray* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDataContainerValue_BoolArray>();
	}
};
static_assert(alignof(UDataContainerValue_BoolArray) == 0x000008, "Wrong alignment on UDataContainerValue_BoolArray");
static_assert(sizeof(UDataContainerValue_BoolArray) == 0x000060, "Wrong size on UDataContainerValue_BoolArray");
static_assert(offsetof(UDataContainerValue_BoolArray, Data) == 0x000050, "Member 'UDataContainerValue_BoolArray::Data' has a wrong offset!");

// Class DataContainer.DataContainerValue_Int32
// 0x0008 (0x0058 - 0x0050)
class UDataContainerValue_Int32 final : public UDataContainerValue_Base
{
public:
	int32                                         Data;                                              // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20C2[0x4];                                     // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DataContainerValue_Int32">();
	}
	static class UDataContainerValue_Int32* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDataContainerValue_Int32>();
	}
};
static_assert(alignof(UDataContainerValue_Int32) == 0x000008, "Wrong alignment on UDataContainerValue_Int32");
static_assert(sizeof(UDataContainerValue_Int32) == 0x000058, "Wrong size on UDataContainerValue_Int32");
static_assert(offsetof(UDataContainerValue_Int32, Data) == 0x000050, "Member 'UDataContainerValue_Int32::Data' has a wrong offset!");

// Class DataContainer.DataContainerValue_Int32Array
// 0x0010 (0x0060 - 0x0050)
class UDataContainerValue_Int32Array final : public UDataContainerValue_Base
{
public:
	TArray<int32>                                 Data;                                              // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ExposeOnSpawn, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DataContainerValue_Int32Array">();
	}
	static class UDataContainerValue_Int32Array* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDataContainerValue_Int32Array>();
	}
};
static_assert(alignof(UDataContainerValue_Int32Array) == 0x000008, "Wrong alignment on UDataContainerValue_Int32Array");
static_assert(sizeof(UDataContainerValue_Int32Array) == 0x000060, "Wrong size on UDataContainerValue_Int32Array");
static_assert(offsetof(UDataContainerValue_Int32Array, Data) == 0x000050, "Member 'UDataContainerValue_Int32Array::Data' has a wrong offset!");

// Class DataContainer.DataContainerValue_Float
// 0x0008 (0x0058 - 0x0050)
class UDataContainerValue_Float final : public UDataContainerValue_Base
{
public:
	float                                         Data;                                              // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20C3[0x4];                                     // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DataContainerValue_Float">();
	}
	static class UDataContainerValue_Float* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDataContainerValue_Float>();
	}
};
static_assert(alignof(UDataContainerValue_Float) == 0x000008, "Wrong alignment on UDataContainerValue_Float");
static_assert(sizeof(UDataContainerValue_Float) == 0x000058, "Wrong size on UDataContainerValue_Float");
static_assert(offsetof(UDataContainerValue_Float, Data) == 0x000050, "Member 'UDataContainerValue_Float::Data' has a wrong offset!");

// Class DataContainer.DataContainerValue_FloatArray
// 0x0010 (0x0060 - 0x0050)
class UDataContainerValue_FloatArray final : public UDataContainerValue_Base
{
public:
	TArray<float>                                 Data;                                              // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ExposeOnSpawn, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DataContainerValue_FloatArray">();
	}
	static class UDataContainerValue_FloatArray* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDataContainerValue_FloatArray>();
	}
};
static_assert(alignof(UDataContainerValue_FloatArray) == 0x000008, "Wrong alignment on UDataContainerValue_FloatArray");
static_assert(sizeof(UDataContainerValue_FloatArray) == 0x000060, "Wrong size on UDataContainerValue_FloatArray");
static_assert(offsetof(UDataContainerValue_FloatArray, Data) == 0x000050, "Member 'UDataContainerValue_FloatArray::Data' has a wrong offset!");

// Class DataContainer.DataContainerValue_Uint8
// 0x0008 (0x0058 - 0x0050)
class UDataContainerValue_Uint8 final : public UDataContainerValue_Base
{
public:
	uint8                                         Data;                                              // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20C4[0x7];                                     // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DataContainerValue_Uint8">();
	}
	static class UDataContainerValue_Uint8* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDataContainerValue_Uint8>();
	}
};
static_assert(alignof(UDataContainerValue_Uint8) == 0x000008, "Wrong alignment on UDataContainerValue_Uint8");
static_assert(sizeof(UDataContainerValue_Uint8) == 0x000058, "Wrong size on UDataContainerValue_Uint8");
static_assert(offsetof(UDataContainerValue_Uint8, Data) == 0x000050, "Member 'UDataContainerValue_Uint8::Data' has a wrong offset!");

// Class DataContainer.DataContainerValue_Uint8Array
// 0x0010 (0x0060 - 0x0050)
class UDataContainerValue_Uint8Array final : public UDataContainerValue_Base
{
public:
	TArray<uint8>                                 Data;                                              // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ExposeOnSpawn, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DataContainerValue_Uint8Array">();
	}
	static class UDataContainerValue_Uint8Array* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDataContainerValue_Uint8Array>();
	}
};
static_assert(alignof(UDataContainerValue_Uint8Array) == 0x000008, "Wrong alignment on UDataContainerValue_Uint8Array");
static_assert(sizeof(UDataContainerValue_Uint8Array) == 0x000060, "Wrong size on UDataContainerValue_Uint8Array");
static_assert(offsetof(UDataContainerValue_Uint8Array, Data) == 0x000050, "Member 'UDataContainerValue_Uint8Array::Data' has a wrong offset!");

// Class DataContainer.DataContainerValue_FString
// 0x0010 (0x0060 - 0x0050)
class UDataContainerValue_FString final : public UDataContainerValue_Base
{
public:
	class FString                                 Data;                                              // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DataContainerValue_FString">();
	}
	static class UDataContainerValue_FString* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDataContainerValue_FString>();
	}
};
static_assert(alignof(UDataContainerValue_FString) == 0x000008, "Wrong alignment on UDataContainerValue_FString");
static_assert(sizeof(UDataContainerValue_FString) == 0x000060, "Wrong size on UDataContainerValue_FString");
static_assert(offsetof(UDataContainerValue_FString, Data) == 0x000050, "Member 'UDataContainerValue_FString::Data' has a wrong offset!");

// Class DataContainer.DataContainerValue_FStringArray
// 0x0010 (0x0060 - 0x0050)
class UDataContainerValue_FStringArray final : public UDataContainerValue_Base
{
public:
	TArray<class FString>                         Data;                                              // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ExposeOnSpawn, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DataContainerValue_FStringArray">();
	}
	static class UDataContainerValue_FStringArray* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDataContainerValue_FStringArray>();
	}
};
static_assert(alignof(UDataContainerValue_FStringArray) == 0x000008, "Wrong alignment on UDataContainerValue_FStringArray");
static_assert(sizeof(UDataContainerValue_FStringArray) == 0x000060, "Wrong size on UDataContainerValue_FStringArray");
static_assert(offsetof(UDataContainerValue_FStringArray, Data) == 0x000050, "Member 'UDataContainerValue_FStringArray::Data' has a wrong offset!");

// Class DataContainer.DataContainerValue_FText
// 0x0018 (0x0068 - 0x0050)
class UDataContainerValue_FText final : public UDataContainerValue_Base
{
public:
	class FText                                   Data;                                              // 0x0050(0x0018)(Edit, BlueprintVisible, ExposeOnSpawn, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DataContainerValue_FText">();
	}
	static class UDataContainerValue_FText* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDataContainerValue_FText>();
	}
};
static_assert(alignof(UDataContainerValue_FText) == 0x000008, "Wrong alignment on UDataContainerValue_FText");
static_assert(sizeof(UDataContainerValue_FText) == 0x000068, "Wrong size on UDataContainerValue_FText");
static_assert(offsetof(UDataContainerValue_FText, Data) == 0x000050, "Member 'UDataContainerValue_FText::Data' has a wrong offset!");

// Class DataContainer.DataContainerValue_FTextArray
// 0x0010 (0x0060 - 0x0050)
class UDataContainerValue_FTextArray final : public UDataContainerValue_Base
{
public:
	TArray<class FText>                           Data;                                              // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ExposeOnSpawn, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DataContainerValue_FTextArray">();
	}
	static class UDataContainerValue_FTextArray* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDataContainerValue_FTextArray>();
	}
};
static_assert(alignof(UDataContainerValue_FTextArray) == 0x000008, "Wrong alignment on UDataContainerValue_FTextArray");
static_assert(sizeof(UDataContainerValue_FTextArray) == 0x000060, "Wrong size on UDataContainerValue_FTextArray");
static_assert(offsetof(UDataContainerValue_FTextArray, Data) == 0x000050, "Member 'UDataContainerValue_FTextArray::Data' has a wrong offset!");

// Class DataContainer.DataContainerValue_FVector
// 0x0018 (0x0068 - 0x0050)
class UDataContainerValue_FVector final : public UDataContainerValue_Base
{
public:
	struct FVector                                Data;                                              // 0x0050(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DataContainerValue_FVector">();
	}
	static class UDataContainerValue_FVector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDataContainerValue_FVector>();
	}
};
static_assert(alignof(UDataContainerValue_FVector) == 0x000008, "Wrong alignment on UDataContainerValue_FVector");
static_assert(sizeof(UDataContainerValue_FVector) == 0x000068, "Wrong size on UDataContainerValue_FVector");
static_assert(offsetof(UDataContainerValue_FVector, Data) == 0x000050, "Member 'UDataContainerValue_FVector::Data' has a wrong offset!");

// Class DataContainer.DataContainerValue_FVectorArray
// 0x0010 (0x0060 - 0x0050)
class UDataContainerValue_FVectorArray final : public UDataContainerValue_Base
{
public:
	TArray<struct FVector>                        Data;                                              // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ExposeOnSpawn, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DataContainerValue_FVectorArray">();
	}
	static class UDataContainerValue_FVectorArray* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDataContainerValue_FVectorArray>();
	}
};
static_assert(alignof(UDataContainerValue_FVectorArray) == 0x000008, "Wrong alignment on UDataContainerValue_FVectorArray");
static_assert(sizeof(UDataContainerValue_FVectorArray) == 0x000060, "Wrong size on UDataContainerValue_FVectorArray");
static_assert(offsetof(UDataContainerValue_FVectorArray, Data) == 0x000050, "Member 'UDataContainerValue_FVectorArray::Data' has a wrong offset!");

// Class DataContainer.DataContainerValue_UObject
// 0x0008 (0x0058 - 0x0050)
class UDataContainerValue_UObject final : public UDataContainerValue_Base
{
public:
	class UObject*                                Data;                                              // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DataContainerValue_UObject">();
	}
	static class UDataContainerValue_UObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDataContainerValue_UObject>();
	}
};
static_assert(alignof(UDataContainerValue_UObject) == 0x000008, "Wrong alignment on UDataContainerValue_UObject");
static_assert(sizeof(UDataContainerValue_UObject) == 0x000058, "Wrong size on UDataContainerValue_UObject");
static_assert(offsetof(UDataContainerValue_UObject, Data) == 0x000050, "Member 'UDataContainerValue_UObject::Data' has a wrong offset!");

// Class DataContainer.DataContainerValue_UObjectArray
// 0x0010 (0x0060 - 0x0050)
class UDataContainerValue_UObjectArray final : public UDataContainerValue_Base
{
public:
	TArray<class UObject*>                        Data;                                              // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ExposeOnSpawn, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DataContainerValue_UObjectArray">();
	}
	static class UDataContainerValue_UObjectArray* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDataContainerValue_UObjectArray>();
	}
};
static_assert(alignof(UDataContainerValue_UObjectArray) == 0x000008, "Wrong alignment on UDataContainerValue_UObjectArray");
static_assert(sizeof(UDataContainerValue_UObjectArray) == 0x000060, "Wrong size on UDataContainerValue_UObjectArray");
static_assert(offsetof(UDataContainerValue_UObjectArray, Data) == 0x000050, "Member 'UDataContainerValue_UObjectArray::Data' has a wrong offset!");

// Class DataContainer.DataContainerValue_TSoftObjectPtr
// 0x0030 (0x0080 - 0x0050)
class UDataContainerValue_TSoftObjectPtr final : public UDataContainerValue_Base
{
public:
	TSoftObjectPtr<class UObject>                 Data;                                              // 0x0050(0x0030)(Edit, BlueprintVisible, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DataContainerValue_TSoftObjectPtr">();
	}
	static class UDataContainerValue_TSoftObjectPtr* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDataContainerValue_TSoftObjectPtr>();
	}
};
static_assert(alignof(UDataContainerValue_TSoftObjectPtr) == 0x000008, "Wrong alignment on UDataContainerValue_TSoftObjectPtr");
static_assert(sizeof(UDataContainerValue_TSoftObjectPtr) == 0x000080, "Wrong size on UDataContainerValue_TSoftObjectPtr");
static_assert(offsetof(UDataContainerValue_TSoftObjectPtr, Data) == 0x000050, "Member 'UDataContainerValue_TSoftObjectPtr::Data' has a wrong offset!");

// Class DataContainer.DataContainerValue_TSoftObjectPtrArray
// 0x0010 (0x0060 - 0x0050)
class UDataContainerValue_TSoftObjectPtrArray final : public UDataContainerValue_Base
{
public:
	TArray<TSoftObjectPtr<class UObject>>         Data;                                              // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ExposeOnSpawn, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DataContainerValue_TSoftObjectPtrArray">();
	}
	static class UDataContainerValue_TSoftObjectPtrArray* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDataContainerValue_TSoftObjectPtrArray>();
	}
};
static_assert(alignof(UDataContainerValue_TSoftObjectPtrArray) == 0x000008, "Wrong alignment on UDataContainerValue_TSoftObjectPtrArray");
static_assert(sizeof(UDataContainerValue_TSoftObjectPtrArray) == 0x000060, "Wrong size on UDataContainerValue_TSoftObjectPtrArray");
static_assert(offsetof(UDataContainerValue_TSoftObjectPtrArray, Data) == 0x000050, "Member 'UDataContainerValue_TSoftObjectPtrArray::Data' has a wrong offset!");

// Class DataContainer.DataContainerValue_UClass
// 0x0008 (0x0058 - 0x0050)
class UDataContainerValue_UClass final : public UDataContainerValue_Base
{
public:
	class UClass*                                 Data;                                              // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DataContainerValue_UClass">();
	}
	static class UDataContainerValue_UClass* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDataContainerValue_UClass>();
	}
};
static_assert(alignof(UDataContainerValue_UClass) == 0x000008, "Wrong alignment on UDataContainerValue_UClass");
static_assert(sizeof(UDataContainerValue_UClass) == 0x000058, "Wrong size on UDataContainerValue_UClass");
static_assert(offsetof(UDataContainerValue_UClass, Data) == 0x000050, "Member 'UDataContainerValue_UClass::Data' has a wrong offset!");

// Class DataContainer.DataContainerValue_UClassArray
// 0x0010 (0x0060 - 0x0050)
class UDataContainerValue_UClassArray final : public UDataContainerValue_Base
{
public:
	TArray<class UClass*>                         Data;                                              // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ExposeOnSpawn, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DataContainerValue_UClassArray">();
	}
	static class UDataContainerValue_UClassArray* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDataContainerValue_UClassArray>();
	}
};
static_assert(alignof(UDataContainerValue_UClassArray) == 0x000008, "Wrong alignment on UDataContainerValue_UClassArray");
static_assert(sizeof(UDataContainerValue_UClassArray) == 0x000060, "Wrong size on UDataContainerValue_UClassArray");
static_assert(offsetof(UDataContainerValue_UClassArray, Data) == 0x000050, "Member 'UDataContainerValue_UClassArray::Data' has a wrong offset!");

// Class DataContainer.DataContainerValue_TSoftClassPtr
// 0x0030 (0x0080 - 0x0050)
class UDataContainerValue_TSoftClassPtr final : public UDataContainerValue_Base
{
public:
	TSoftClassPtr<class UClass>                   Data;                                              // 0x0050(0x0030)(Edit, BlueprintVisible, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DataContainerValue_TSoftClassPtr">();
	}
	static class UDataContainerValue_TSoftClassPtr* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDataContainerValue_TSoftClassPtr>();
	}
};
static_assert(alignof(UDataContainerValue_TSoftClassPtr) == 0x000008, "Wrong alignment on UDataContainerValue_TSoftClassPtr");
static_assert(sizeof(UDataContainerValue_TSoftClassPtr) == 0x000080, "Wrong size on UDataContainerValue_TSoftClassPtr");
static_assert(offsetof(UDataContainerValue_TSoftClassPtr, Data) == 0x000050, "Member 'UDataContainerValue_TSoftClassPtr::Data' has a wrong offset!");

// Class DataContainer.DataContainerValue_TSoftClassPtrArray
// 0x0010 (0x0060 - 0x0050)
class UDataContainerValue_TSoftClassPtrArray final : public UDataContainerValue_Base
{
public:
	TArray<TSoftClassPtr<class UClass>>           Data;                                              // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ExposeOnSpawn, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DataContainerValue_TSoftClassPtrArray">();
	}
	static class UDataContainerValue_TSoftClassPtrArray* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDataContainerValue_TSoftClassPtrArray>();
	}
};
static_assert(alignof(UDataContainerValue_TSoftClassPtrArray) == 0x000008, "Wrong alignment on UDataContainerValue_TSoftClassPtrArray");
static_assert(sizeof(UDataContainerValue_TSoftClassPtrArray) == 0x000060, "Wrong size on UDataContainerValue_TSoftClassPtrArray");
static_assert(offsetof(UDataContainerValue_TSoftClassPtrArray, Data) == 0x000050, "Member 'UDataContainerValue_TSoftClassPtrArray::Data' has a wrong offset!");

// Class DataContainer.DataContainerValue_DataTable
// 0x0008 (0x0058 - 0x0050)
class UDataContainerValue_DataTable final : public UDataContainerValue_Base
{
public:
	class UDataTable*                             Data;                                              // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DataContainerValue_DataTable">();
	}
	static class UDataContainerValue_DataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDataContainerValue_DataTable>();
	}
};
static_assert(alignof(UDataContainerValue_DataTable) == 0x000008, "Wrong alignment on UDataContainerValue_DataTable");
static_assert(sizeof(UDataContainerValue_DataTable) == 0x000058, "Wrong size on UDataContainerValue_DataTable");
static_assert(offsetof(UDataContainerValue_DataTable, Data) == 0x000050, "Member 'UDataContainerValue_DataTable::Data' has a wrong offset!");

// Class DataContainer.DataContainerValue_DataTableArray
// 0x0010 (0x0060 - 0x0050)
class UDataContainerValue_DataTableArray final : public UDataContainerValue_Base
{
public:
	TArray<class UDataTable*>                     Data;                                              // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ExposeOnSpawn, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DataContainerValue_DataTableArray">();
	}
	static class UDataContainerValue_DataTableArray* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDataContainerValue_DataTableArray>();
	}
};
static_assert(alignof(UDataContainerValue_DataTableArray) == 0x000008, "Wrong alignment on UDataContainerValue_DataTableArray");
static_assert(sizeof(UDataContainerValue_DataTableArray) == 0x000060, "Wrong size on UDataContainerValue_DataTableArray");
static_assert(offsetof(UDataContainerValue_DataTableArray, Data) == 0x000050, "Member 'UDataContainerValue_DataTableArray::Data' has a wrong offset!");

}

