#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: POLYGON

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "Engine_structs.hpp"
#include "PhysicsCore_structs.hpp"
#include "DataContainer_structs.hpp"


namespace SDK
{

// Enum POLYGON.EAccrualTypeGameScore
// NumValues: 0x0009
enum class EAccrualTypeGameScore : uint8
{
	NONE                                     = 0,
	KILL                                     = 1,
	HEADSHOT                                 = 2,
	KILL_ASSIST                              = 3,
	KILL_CONQUEST_DEFENCE                    = 4,
	KILL_CONQUEST_ATTACK                     = 5,
	CONQUEST_CAPTURE                         = 6,
	CONQUEST_CAPTURING                       = 7,
	EAccrualTypeGameScore_MAX                = 8,
};

// Enum POLYGON.EModifiedData
// NumValues: 0x0005
enum class EModifiedData : uint8
{
	NONE                                     = 0,
	WEAPONS                                  = 1,
	GEAR                                     = 2,
	STATISTICS                               = 3,
	EModifiedData_MAX                        = 4,
};

// Enum POLYGON.EPenetrationTraceType
// NumValues: 0x0004
enum class EPenetrationTraceType : uint8
{
	BACK_TRACE                               = 0,
	BY_COMPONENT                             = 1,
	TWO_SIDED_GEOMETRY                       = 2,
	EPenetrationTraceType_MAX                = 3,
};

// Enum POLYGON.EAtmosphereType
// NumValues: 0x0004
enum class EAtmosphereType : uint8
{
	CONSTANT                                 = 0,
	CURVE                                    = 1,
	EARTH                                    = 2,
	EAtmosphereType_MAX                      = 3,
};

// Enum POLYGON.ECameraViewMode
// NumValues: 0x0003
enum class ECameraViewMode : uint8
{
	FIRST_PERSON                             = 0,
	THIRD_PERSON                             = 1,
	ECameraViewMode_MAX                      = 2,
};

// Enum POLYGON.ECharacterPoseState
// NumValues: 0x0006
enum class ECharacterPoseState : uint8
{
	NONE                                     = 0,
	STAND                                    = 1,
	CROUCN                                   = 2,
	LIE                                      = 3,
	AIR                                      = 4,
	ECharacterPoseState_MAX                  = 5,
};

// Enum POLYGON.EControlPoint
// NumValues: 0x0008
enum class EControlPoint : uint8
{
	NONE_                                    = 0,
	ALPHA_                                   = 1,
	BRAVO_                                   = 2,
	CHARLIE_                                 = 3,
	DELTA_                                   = 4,
	ECHO_                                    = 5,
	FOXTROT_                                 = 6,
	EControlPoint_MAX                        = 7,
};

// Enum POLYGON.EPG_GameState
// NumValues: 0x0007
enum class EPG_GameState : uint8
{
	NONE                                     = 0,
	WAITING_PLAYERS                          = 1,
	PAUSE                                    = 2,
	COUNTDOWN                                = 3,
	GAME                                     = 4,
	ENDED                                    = 5,
	EPG_MAX                                  = 6,
};

// Enum POLYGON.EGunClass
// NumValues: 0x000A
enum class EGunClass : uint8
{
	NONE                                     = 0,
	ASSAULT                                  = 1,
	SMG                                      = 2,
	MARKSMAN                                 = 3,
	LMG                                      = 4,
	SHOTGUN                                  = 5,
	SNIPER                                   = 6,
	PISTOL                                   = 7,
	REVOLVER                                 = 8,
	EGunClass_MAX                            = 9,
};

// Enum POLYGON.EGunModuleType
// NumValues: 0x0009
enum class EGunModuleType : uint8
{
	NONE                                     = 0,
	OPTIC                                    = 1,
	BARREL                                   = 2,
	UNDERBARREL                              = 3,
	MAGAZINE                                 = 4,
	ACCESSORY                                = 5,
	SKIN                                     = 6,
	STRAP                                    = 7,
	EGunModuleType_MAX                       = 8,
};

// Enum POLYGON.EGunShootingType
// NumValues: 0x0004
enum class EGunShootingType : uint8
{
	BOLT                                     = 0,
	SEMI_AUTO                                = 1,
	AUTO                                     = 2,
	EGunShootingType_MAX                     = 3,
};

// Enum POLYGON.EGunSlot
// NumValues: 0x0003
enum class EGunSlot : uint8
{
	PRIMARY                                  = 0,
	SECONDARY                                = 1,
	EGunSlot_MAX                             = 2,
};

// Enum POLYGON.EStaminaState
// NumValues: 0x0004
enum class EStaminaState : uint8
{
	IDLE                                     = 0,
	INCREASE                                 = 1,
	DECREASE                                 = 2,
	EStaminaState_MAX                        = 3,
};

// Enum POLYGON.EItemRareType
// NumValues: 0x0008
enum class EItemRareType : uint8
{
	NONE                                     = 0,
	COMMON                                   = 1,
	RARE                                     = 2,
	EPIC                                     = 3,
	LEGENDARY                                = 4,
	MYTHICAL                                 = 5,
	RELIC                                    = 6,
	EItemRareType_MAX                        = 7,
};

// Enum POLYGON.EItemType
// NumValues: 0x0006
enum class EItemType : uint8
{
	NONE                                     = 0,
	GUN                                      = 1,
	GRENADE                                  = 2,
	MODULE                                   = 3,
	WATCH                                    = 4,
	EItemType_MAX                            = 5,
};

// Enum POLYGON.EGameMode
// NumValues: 0x0004
enum class EGameMode : uint8
{
	NONE                                     = 0,
	CONQUEST                                 = 1,
	KING_OF_HILL                             = 2,
	EGameMode_MAX                            = 3,
};

// Enum POLYGON.EMessageType
// NumValues: 0x0006
enum class EMessageType : uint8
{
	ALL                                      = 0,
	TEAM                                     = 1,
	SQUAD                                    = 2,
	PRIVATE                                  = 3,
	SYSTEM                                   = 4,
	EMessageType_MAX                         = 5,
};

// Enum POLYGON.EPlayerAction
// NumValues: 0x0006
enum class EPlayerAction : uint8
{
	NONE                                     = 0,
	RELOADING                                = 1,
	BOLTING                                  = 2,
	CHANGING                                 = 3,
	THROW_GRENADE                            = 4,
	EPlayerAction_MAX                        = 5,
};

// Enum POLYGON.EPlayerDeathType
// NumValues: 0x0004
enum class EPlayerDeathType : uint8
{
	NONE                                     = 0,
	HEADSHOT                                 = 1,
	GRENADE                                  = 2,
	EPlayerDeathType_MAX                     = 3,
};

// Enum POLYGON.ETeam
// NumValues: 0x0005
enum class ETeam : uint8
{
	NONE                                     = 0,
	NOBODY                                   = 1,
	ALPHA                                    = 2,
	BRAVO                                    = 3,
	ETeam_MAX                                = 4,
};

// ScriptStruct POLYGON.GameChatMessage
// 0x0020 (0x0020 - 0x0000)
struct FGameChatMessage final
{
public:
	class APG_PlayerState_Game*                   Sender;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMessageType                                  MessageType;                                       // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BF4[0x7];                                     // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Message;                                           // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameChatMessage) == 0x000008, "Wrong alignment on FGameChatMessage");
static_assert(sizeof(FGameChatMessage) == 0x000020, "Wrong size on FGameChatMessage");
static_assert(offsetof(FGameChatMessage, Sender) == 0x000000, "Member 'FGameChatMessage::Sender' has a wrong offset!");
static_assert(offsetof(FGameChatMessage, MessageType) == 0x000008, "Member 'FGameChatMessage::MessageType' has a wrong offset!");
static_assert(offsetof(FGameChatMessage, Message) == 0x000010, "Member 'FGameChatMessage::Message' has a wrong offset!");

// ScriptStruct POLYGON.ScoreInfoBlueprint
// 0x0010 (0x0010 - 0x0000)
struct FScoreInfoBlueprint final
{
public:
	int32                                         Score;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAccrualTypeGameScore                         ScoreType;                                         // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BF5[0x3];                                     // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                Giver;                                             // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScoreInfoBlueprint) == 0x000008, "Wrong alignment on FScoreInfoBlueprint");
static_assert(sizeof(FScoreInfoBlueprint) == 0x000010, "Wrong size on FScoreInfoBlueprint");
static_assert(offsetof(FScoreInfoBlueprint, Score) == 0x000000, "Member 'FScoreInfoBlueprint::Score' has a wrong offset!");
static_assert(offsetof(FScoreInfoBlueprint, ScoreType) == 0x000004, "Member 'FScoreInfoBlueprint::ScoreType' has a wrong offset!");
static_assert(offsetof(FScoreInfoBlueprint, Giver) == 0x000008, "Member 'FScoreInfoBlueprint::Giver' has a wrong offset!");

// ScriptStruct POLYGON.BallisticMaterialResponseMapEntry
// 0x0034 (0x0034 - 0x0000)
struct FBallisticMaterialResponseMapEntry final
{
public:
	EPenetrationTraceType                         PenTraceType;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NeverPenetrate;                                    // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BF6[0x2];                                     // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PenetrationDepthMultiplier;                        // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PenetrationNormalization;                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PenetrationNormalizationGrazing;                   // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PenetrationEntryAngleSpread;                       // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PenetrationExitAngleSpread;                        // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NeverRicochet;                                     // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BF7[0x3];                                     // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RicochetProbabilityMultiplier;                     // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RicochetRestitution;                               // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RicochetRestitutionInfluence;                      // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RicochetFriction;                                  // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RicochetFrictionInfluence;                         // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RicochetSpread;                                    // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBallisticMaterialResponseMapEntry) == 0x000004, "Wrong alignment on FBallisticMaterialResponseMapEntry");
static_assert(sizeof(FBallisticMaterialResponseMapEntry) == 0x000034, "Wrong size on FBallisticMaterialResponseMapEntry");
static_assert(offsetof(FBallisticMaterialResponseMapEntry, PenTraceType) == 0x000000, "Member 'FBallisticMaterialResponseMapEntry::PenTraceType' has a wrong offset!");
static_assert(offsetof(FBallisticMaterialResponseMapEntry, NeverPenetrate) == 0x000001, "Member 'FBallisticMaterialResponseMapEntry::NeverPenetrate' has a wrong offset!");
static_assert(offsetof(FBallisticMaterialResponseMapEntry, PenetrationDepthMultiplier) == 0x000004, "Member 'FBallisticMaterialResponseMapEntry::PenetrationDepthMultiplier' has a wrong offset!");
static_assert(offsetof(FBallisticMaterialResponseMapEntry, PenetrationNormalization) == 0x000008, "Member 'FBallisticMaterialResponseMapEntry::PenetrationNormalization' has a wrong offset!");
static_assert(offsetof(FBallisticMaterialResponseMapEntry, PenetrationNormalizationGrazing) == 0x00000C, "Member 'FBallisticMaterialResponseMapEntry::PenetrationNormalizationGrazing' has a wrong offset!");
static_assert(offsetof(FBallisticMaterialResponseMapEntry, PenetrationEntryAngleSpread) == 0x000010, "Member 'FBallisticMaterialResponseMapEntry::PenetrationEntryAngleSpread' has a wrong offset!");
static_assert(offsetof(FBallisticMaterialResponseMapEntry, PenetrationExitAngleSpread) == 0x000014, "Member 'FBallisticMaterialResponseMapEntry::PenetrationExitAngleSpread' has a wrong offset!");
static_assert(offsetof(FBallisticMaterialResponseMapEntry, NeverRicochet) == 0x000018, "Member 'FBallisticMaterialResponseMapEntry::NeverRicochet' has a wrong offset!");
static_assert(offsetof(FBallisticMaterialResponseMapEntry, RicochetProbabilityMultiplier) == 0x00001C, "Member 'FBallisticMaterialResponseMapEntry::RicochetProbabilityMultiplier' has a wrong offset!");
static_assert(offsetof(FBallisticMaterialResponseMapEntry, RicochetRestitution) == 0x000020, "Member 'FBallisticMaterialResponseMapEntry::RicochetRestitution' has a wrong offset!");
static_assert(offsetof(FBallisticMaterialResponseMapEntry, RicochetRestitutionInfluence) == 0x000024, "Member 'FBallisticMaterialResponseMapEntry::RicochetRestitutionInfluence' has a wrong offset!");
static_assert(offsetof(FBallisticMaterialResponseMapEntry, RicochetFriction) == 0x000028, "Member 'FBallisticMaterialResponseMapEntry::RicochetFriction' has a wrong offset!");
static_assert(offsetof(FBallisticMaterialResponseMapEntry, RicochetFrictionInfluence) == 0x00002C, "Member 'FBallisticMaterialResponseMapEntry::RicochetFrictionInfluence' has a wrong offset!");
static_assert(offsetof(FBallisticMaterialResponseMapEntry, RicochetSpread) == 0x000030, "Member 'FBallisticMaterialResponseMapEntry::RicochetSpread' has a wrong offset!");

// ScriptStruct POLYGON.BattlePassReward
// 0x00B8 (0x00C0 - 0x0008)
struct FBattlePassReward final : public FTableRowBase
{
public:
	int32                                         Level;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredExperience;                                // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFree;                                           // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BF8[0x3];                                     // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ID;                                                // 0x0014(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Class;                                             // 0x001C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BF9[0x4];                                     // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Name;                                              // 0x0028(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         Number;                                            // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BFA[0x4];                                     // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              Image;                                             // 0x0048(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Icon;                                              // 0x0078(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x00A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemRareType                                 Rare;                                              // 0x00B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BFB[0x7];                                     // 0x00B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBattlePassReward) == 0x000008, "Wrong alignment on FBattlePassReward");
static_assert(sizeof(FBattlePassReward) == 0x0000C0, "Wrong size on FBattlePassReward");
static_assert(offsetof(FBattlePassReward, Level) == 0x000008, "Member 'FBattlePassReward::Level' has a wrong offset!");
static_assert(offsetof(FBattlePassReward, RequiredExperience) == 0x00000C, "Member 'FBattlePassReward::RequiredExperience' has a wrong offset!");
static_assert(offsetof(FBattlePassReward, bIsFree) == 0x000010, "Member 'FBattlePassReward::bIsFree' has a wrong offset!");
static_assert(offsetof(FBattlePassReward, ID) == 0x000014, "Member 'FBattlePassReward::ID' has a wrong offset!");
static_assert(offsetof(FBattlePassReward, Class) == 0x00001C, "Member 'FBattlePassReward::Class' has a wrong offset!");
static_assert(offsetof(FBattlePassReward, Name) == 0x000028, "Member 'FBattlePassReward::Name' has a wrong offset!");
static_assert(offsetof(FBattlePassReward, Number) == 0x000040, "Member 'FBattlePassReward::Number' has a wrong offset!");
static_assert(offsetof(FBattlePassReward, Image) == 0x000048, "Member 'FBattlePassReward::Image' has a wrong offset!");
static_assert(offsetof(FBattlePassReward, Icon) == 0x000078, "Member 'FBattlePassReward::Icon' has a wrong offset!");
static_assert(offsetof(FBattlePassReward, Color) == 0x0000A8, "Member 'FBattlePassReward::Color' has a wrong offset!");
static_assert(offsetof(FBattlePassReward, Rare) == 0x0000B8, "Member 'FBattlePassReward::Rare' has a wrong offset!");

// ScriptStruct POLYGON.BeaconSlotRequest
// 0x0020 (0x0020 - 0x0000)
struct FBeaconSlotRequest final
{
public:
	class APG_BeaconClient*                       BeaconClient;                                      // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FUniqueNetIdRepl>               UserIds;                                           // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BFC[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBeaconSlotRequest) == 0x000008, "Wrong alignment on FBeaconSlotRequest");
static_assert(sizeof(FBeaconSlotRequest) == 0x000020, "Wrong size on FBeaconSlotRequest");
static_assert(offsetof(FBeaconSlotRequest, BeaconClient) == 0x000000, "Member 'FBeaconSlotRequest::BeaconClient' has a wrong offset!");
static_assert(offsetof(FBeaconSlotRequest, UserIds) == 0x000008, "Member 'FBeaconSlotRequest::UserIds' has a wrong offset!");

// ScriptStruct POLYGON.DataTableReference
// 0x0008 (0x0010 - 0x0008)
struct FDataTableReference final : public FTableRowBase
{
public:
	class UDataTable*                             DataTable;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDataTableReference) == 0x000008, "Wrong alignment on FDataTableReference");
static_assert(sizeof(FDataTableReference) == 0x000010, "Wrong size on FDataTableReference");
static_assert(offsetof(FDataTableReference, DataTable) == 0x000008, "Member 'FDataTableReference::DataTable' has a wrong offset!");

// ScriptStruct POLYGON.GunModuleInfo
// 0x0040 (0x0040 - 0x0000)
struct FGunModuleInfo final
{
public:
	TSubclassOf<class AItem_Module_General>       ModuleClass;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class AItem_Module_General>> Parents;                                           // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class AItem_Module_General>> Children;                                          // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         RequiredExperience;                                // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredLevel;                                     // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredCredits;                                   // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredCrowns;                                    // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDataContainerObjectWrapper            CustomData;                                        // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGunModuleInfo) == 0x000008, "Wrong alignment on FGunModuleInfo");
static_assert(sizeof(FGunModuleInfo) == 0x000040, "Wrong size on FGunModuleInfo");
static_assert(offsetof(FGunModuleInfo, ModuleClass) == 0x000000, "Member 'FGunModuleInfo::ModuleClass' has a wrong offset!");
static_assert(offsetof(FGunModuleInfo, Parents) == 0x000008, "Member 'FGunModuleInfo::Parents' has a wrong offset!");
static_assert(offsetof(FGunModuleInfo, Children) == 0x000018, "Member 'FGunModuleInfo::Children' has a wrong offset!");
static_assert(offsetof(FGunModuleInfo, RequiredExperience) == 0x000028, "Member 'FGunModuleInfo::RequiredExperience' has a wrong offset!");
static_assert(offsetof(FGunModuleInfo, RequiredLevel) == 0x00002C, "Member 'FGunModuleInfo::RequiredLevel' has a wrong offset!");
static_assert(offsetof(FGunModuleInfo, RequiredCredits) == 0x000030, "Member 'FGunModuleInfo::RequiredCredits' has a wrong offset!");
static_assert(offsetof(FGunModuleInfo, RequiredCrowns) == 0x000034, "Member 'FGunModuleInfo::RequiredCrowns' has a wrong offset!");
static_assert(offsetof(FGunModuleInfo, CustomData) == 0x000038, "Member 'FGunModuleInfo::CustomData' has a wrong offset!");

// ScriptStruct POLYGON.PlayerAssist
// 0x0060 (0x0060 - 0x0000)
struct FPlayerAssist final
{
public:
	class APG_PlayerState_Game*                   PlayerAssist;                                      // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class AActor*, int32>                    DamageCausers;                                     // 0x0008(0x0050)(NativeAccessSpecifierPublic)
	struct FTimerHandle                           TimerResetAssist;                                  // 0x0058(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerAssist) == 0x000008, "Wrong alignment on FPlayerAssist");
static_assert(sizeof(FPlayerAssist) == 0x000060, "Wrong size on FPlayerAssist");
static_assert(offsetof(FPlayerAssist, PlayerAssist) == 0x000000, "Member 'FPlayerAssist::PlayerAssist' has a wrong offset!");
static_assert(offsetof(FPlayerAssist, DamageCausers) == 0x000008, "Member 'FPlayerAssist::DamageCausers' has a wrong offset!");
static_assert(offsetof(FPlayerAssist, TimerResetAssist) == 0x000058, "Member 'FPlayerAssist::TimerResetAssist' has a wrong offset!");

// ScriptStruct POLYGON.ItemEntry
// 0x0008 (0x0010 - 0x0008)
struct FItemEntry final : public FTableRowBase
{
public:
	TSubclassOf<class AItem_General>              Item;                                              // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemEntry) == 0x000008, "Wrong alignment on FItemEntry");
static_assert(sizeof(FItemEntry) == 0x000010, "Wrong size on FItemEntry");
static_assert(offsetof(FItemEntry, Item) == 0x000008, "Member 'FItemEntry::Item' has a wrong offset!");

// ScriptStruct POLYGON.GunShot
// 0x0020 (0x0020 - 0x0000)
struct FGunShot final
{
public:
	struct FVector_NetQuantizeNormal              ShotDirection;                                     // 0x0000(0x0018)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         RandomSeed;                                        // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BFD[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGunShot) == 0x000008, "Wrong alignment on FGunShot");
static_assert(sizeof(FGunShot) == 0x000020, "Wrong size on FGunShot");
static_assert(offsetof(FGunShot, ShotDirection) == 0x000000, "Member 'FGunShot::ShotDirection' has a wrong offset!");
static_assert(offsetof(FGunShot, RandomSeed) == 0x000018, "Member 'FGunShot::RandomSeed' has a wrong offset!");

// ScriptStruct POLYGON.GunHitOnCharacter
// 0x0028 (0x0028 - 0x0000)
struct FGunHitOnCharacter final
{
public:
	struct FVector_NetQuantize                    Location;                                          // 0x0000(0x0018)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  Actor;                                             // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         BoneIndex;                                         // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPhysicalSurface                              PhysSurfaceType;                                   // 0x0021(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BFE[0x6];                                     // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGunHitOnCharacter) == 0x000008, "Wrong alignment on FGunHitOnCharacter");
static_assert(sizeof(FGunHitOnCharacter) == 0x000028, "Wrong size on FGunHitOnCharacter");
static_assert(offsetof(FGunHitOnCharacter, Location) == 0x000000, "Member 'FGunHitOnCharacter::Location' has a wrong offset!");
static_assert(offsetof(FGunHitOnCharacter, Actor) == 0x000018, "Member 'FGunHitOnCharacter::Actor' has a wrong offset!");
static_assert(offsetof(FGunHitOnCharacter, BoneIndex) == 0x000020, "Member 'FGunHitOnCharacter::BoneIndex' has a wrong offset!");
static_assert(offsetof(FGunHitOnCharacter, PhysSurfaceType) == 0x000021, "Member 'FGunHitOnCharacter::PhysSurfaceType' has a wrong offset!");

// ScriptStruct POLYGON.LevelInfo
// 0x0040 (0x0048 - 0x0008)
struct FLevelInfo final : public FTableRowBase
{
public:
	class FName                                   LevelID;                                           // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProgressRequired;                                  // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              LevelIcon;                                         // 0x0018(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLevelInfo) == 0x000008, "Wrong alignment on FLevelInfo");
static_assert(sizeof(FLevelInfo) == 0x000048, "Wrong size on FLevelInfo");
static_assert(offsetof(FLevelInfo, LevelID) == 0x000008, "Member 'FLevelInfo::LevelID' has a wrong offset!");
static_assert(offsetof(FLevelInfo, Level) == 0x000010, "Member 'FLevelInfo::Level' has a wrong offset!");
static_assert(offsetof(FLevelInfo, ProgressRequired) == 0x000014, "Member 'FLevelInfo::ProgressRequired' has a wrong offset!");
static_assert(offsetof(FLevelInfo, LevelIcon) == 0x000018, "Member 'FLevelInfo::LevelIcon' has a wrong offset!");

// ScriptStruct POLYGON.MapInfo
// 0x00E0 (0x00E8 - 0x0008)
struct FMapInfo final : public FTableRowBase
{
public:
	class FName                                   MapRowName;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MapName;                                           // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   MapDisplayName;                                    // 0x0020(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<EGameMode>                             GameModes;                                         // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         MaxPlayers;                                        // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxScoreForWin;                                    // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealthProtectionDuration;                          // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GrenadeDamageRadiusMultiplier;                     // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CapturePointsPerBeat;                              // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BFF[0x4];                                     // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              MapPreview;                                        // 0x0060(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              MinimapImage;                                      // 0x0090(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Dimension;                                         // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C00[0x4];                                     // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CameraPosition;                                    // 0x00C8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraRotate;                                      // 0x00E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsNew;                                            // 0x00E4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDevelopment;                                     // 0x00E5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C01[0x2];                                     // 0x00E6(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMapInfo) == 0x000008, "Wrong alignment on FMapInfo");
static_assert(sizeof(FMapInfo) == 0x0000E8, "Wrong size on FMapInfo");
static_assert(offsetof(FMapInfo, MapRowName) == 0x000008, "Member 'FMapInfo::MapRowName' has a wrong offset!");
static_assert(offsetof(FMapInfo, MapName) == 0x000010, "Member 'FMapInfo::MapName' has a wrong offset!");
static_assert(offsetof(FMapInfo, MapDisplayName) == 0x000020, "Member 'FMapInfo::MapDisplayName' has a wrong offset!");
static_assert(offsetof(FMapInfo, GameModes) == 0x000038, "Member 'FMapInfo::GameModes' has a wrong offset!");
static_assert(offsetof(FMapInfo, MaxPlayers) == 0x000048, "Member 'FMapInfo::MaxPlayers' has a wrong offset!");
static_assert(offsetof(FMapInfo, MaxScoreForWin) == 0x00004C, "Member 'FMapInfo::MaxScoreForWin' has a wrong offset!");
static_assert(offsetof(FMapInfo, HealthProtectionDuration) == 0x000050, "Member 'FMapInfo::HealthProtectionDuration' has a wrong offset!");
static_assert(offsetof(FMapInfo, GrenadeDamageRadiusMultiplier) == 0x000054, "Member 'FMapInfo::GrenadeDamageRadiusMultiplier' has a wrong offset!");
static_assert(offsetof(FMapInfo, CapturePointsPerBeat) == 0x000058, "Member 'FMapInfo::CapturePointsPerBeat' has a wrong offset!");
static_assert(offsetof(FMapInfo, MapPreview) == 0x000060, "Member 'FMapInfo::MapPreview' has a wrong offset!");
static_assert(offsetof(FMapInfo, MinimapImage) == 0x000090, "Member 'FMapInfo::MinimapImage' has a wrong offset!");
static_assert(offsetof(FMapInfo, Dimension) == 0x0000C0, "Member 'FMapInfo::Dimension' has a wrong offset!");
static_assert(offsetof(FMapInfo, CameraPosition) == 0x0000C8, "Member 'FMapInfo::CameraPosition' has a wrong offset!");
static_assert(offsetof(FMapInfo, CameraRotate) == 0x0000E0, "Member 'FMapInfo::CameraRotate' has a wrong offset!");
static_assert(offsetof(FMapInfo, bIsNew) == 0x0000E4, "Member 'FMapInfo::bIsNew' has a wrong offset!");
static_assert(offsetof(FMapInfo, IsDevelopment) == 0x0000E5, "Member 'FMapInfo::IsDevelopment' has a wrong offset!");

// ScriptStruct POLYGON.PlayerId
// 0x0020 (0x0020 - 0x0000)
struct FPlayerId final
{
public:
	class FString                                 PlayerMasterId;                                    // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlayerTitleId;                                     // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerId) == 0x000008, "Wrong alignment on FPlayerId");
static_assert(sizeof(FPlayerId) == 0x000020, "Wrong size on FPlayerId");
static_assert(offsetof(FPlayerId, PlayerMasterId) == 0x000000, "Member 'FPlayerId::PlayerMasterId' has a wrong offset!");
static_assert(offsetof(FPlayerId, PlayerTitleId) == 0x000010, "Member 'FPlayerId::PlayerTitleId' has a wrong offset!");

// ScriptStruct POLYGON.ScoreInfo
// 0x0010 (0x0010 - 0x0000)
struct FScoreInfo final
{
public:
	uint16                                        Score;                                             // 0x0000(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAccrualTypeGameScore                         ScoreType;                                         // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C02[0x5];                                     // 0x0003(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                Giver;                                             // 0x0008(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScoreInfo) == 0x000008, "Wrong alignment on FScoreInfo");
static_assert(sizeof(FScoreInfo) == 0x000010, "Wrong size on FScoreInfo");
static_assert(offsetof(FScoreInfo, Score) == 0x000000, "Member 'FScoreInfo::Score' has a wrong offset!");
static_assert(offsetof(FScoreInfo, ScoreType) == 0x000002, "Member 'FScoreInfo::ScoreType' has a wrong offset!");
static_assert(offsetof(FScoreInfo, Giver) == 0x000008, "Member 'FScoreInfo::Giver' has a wrong offset!");

}

