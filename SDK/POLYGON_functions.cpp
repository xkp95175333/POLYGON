#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: POLYGON

#include "Basic.hpp"

#include "POLYGON_classes.hpp"
#include "POLYGON_parameters.hpp"


namespace SDK
{

// Function POLYGON.PG_PlayerState_Base.SetPlayerName
// (Native, Public, BlueprintCallable)
// Parameters:
// class FString                           PlayerName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APG_PlayerState_Base::SetPlayerName(const class FString& PlayerName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_PlayerState_Base", "SetPlayerName");

	Params::PG_PlayerState_Base_SetPlayerName Parms{};

	Parms.PlayerName = std::move(PlayerName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.PG_PlayerState_Base.UpdatePlayerCombinedInfo
// (Native, Protected, HasOutParams)
// Parameters:
// TArray<EModifiedData>                   ModifiedData                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           CustomDelegateString                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APG_PlayerState_Base::UpdatePlayerCombinedInfo(const TArray<EModifiedData>& ModifiedData, const class FString& CustomDelegateString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_PlayerState_Base", "UpdatePlayerCombinedInfo");

	Params::PG_PlayerState_Base_UpdatePlayerCombinedInfo Parms{};

	Parms.ModifiedData = std::move(ModifiedData);
	Parms.CustomDelegateString = std::move(CustomDelegateString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.PG_PlayerState_Base.GetUniqueNetId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FUniqueNetIdRepl           ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FUniqueNetIdRepl APG_PlayerState_Base::GetUniqueNetId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_PlayerState_Base", "GetUniqueNetId");

	Params::PG_PlayerState_Base_GetUniqueNetId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function POLYGON.PG_PlayerState_Game.OnRep_NumberDeaths
// (Final, Native, Private)

void APG_PlayerState_Game::OnRep_NumberDeaths()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_PlayerState_Game", "OnRep_NumberDeaths");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.PG_PlayerState_Game.OnRep_NumberKills
// (Final, Native, Private)

void APG_PlayerState_Game::OnRep_NumberKills()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_PlayerState_Game", "OnRep_NumberKills");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.PG_PlayerState_Game.OnRep_Team
// (Final, Native, Private)

void APG_PlayerState_Game::OnRep_Team()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_PlayerState_Game", "OnRep_Team");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.PG_PlayerState_Game.OnRep_VoteKickPlayers
// (Final, Native, Private)

void APG_PlayerState_Game::OnRep_VoteKickPlayers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_PlayerState_Game", "OnRep_VoteKickPlayers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.PG_PlayerState_Game.SetTeam
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETeam                                   NewTeam                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APG_PlayerState_Game::SetTeam(const ETeam NewTeam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_PlayerState_Game", "SetTeam");

	Params::PG_PlayerState_Game_SetTeam Parms{};

	Parms.NewTeam = NewTeam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.PG_PlayerState_Game.CustomIsInactive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APG_PlayerState_Game::CustomIsInactive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_PlayerState_Game", "CustomIsInactive");

	Params::PG_PlayerState_Game_CustomIsInactive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function POLYGON.TraceProjectile.Spawn
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TSubclassOf<class ATraceProjectile>     bulletClass                                            (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AItem_Gun_General*                Gun                                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          SpawnLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          StartVelocity                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   RandomSeed                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATraceProjectile::Spawn(TSubclassOf<class ATraceProjectile> bulletClass, class AItem_Gun_General* Gun, const struct FVector& SpawnLocation, const struct FVector& StartVelocity, const uint8 RandomSeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TraceProjectile", "Spawn");

	Params::TraceProjectile_Spawn Parms{};

	Parms.bulletClass = bulletClass;
	Parms.Gun = Gun;
	Parms.SpawnLocation = std::move(SpawnLocation);
	Parms.StartVelocity = std::move(StartVelocity);
	Parms.RandomSeed = RandomSeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.TraceProjectile.SpawnWithExactVelocity
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TSubclassOf<class ATraceProjectile>     bulletClass                                            (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AItem_Gun_General*                Gun                                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          SpawnLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          StartVelocity                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   RandomSeed                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATraceProjectile::SpawnWithExactVelocity(TSubclassOf<class ATraceProjectile> bulletClass, class AItem_Gun_General* Gun, const struct FVector& SpawnLocation, const struct FVector& StartVelocity, const uint8 RandomSeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TraceProjectile", "SpawnWithExactVelocity");

	Params::TraceProjectile_SpawnWithExactVelocity Parms{};

	Parms.bulletClass = bulletClass;
	Parms.Gun = Gun;
	Parms.SpawnLocation = std::move(SpawnLocation);
	Parms.StartVelocity = std::move(StartVelocity);
	Parms.RandomSeed = RandomSeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.TraceProjectile.Deactivate
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ATraceProjectile::Deactivate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TraceProjectile", "Deactivate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.TraceProjectile.OnDeactivated
// (Native, Event, Public, BlueprintEvent)

void ATraceProjectile::OnDeactivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TraceProjectile", "OnDeactivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.TraceProjectile.OnImpact
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// bool                                    Ricochet                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    PassedThrough                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ExitVelocity                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Impulse                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PenetrationDepth                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ATraceProjectile::OnImpact(bool Ricochet, bool PassedThrough, const struct FVector& ExitVelocity, const struct FVector& Impulse, float PenetrationDepth, const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TraceProjectile", "OnImpact");

	Params::TraceProjectile_OnImpact Parms{};

	Parms.Ricochet = Ricochet;
	Parms.PassedThrough = PassedThrough;
	Parms.ExitVelocity = std::move(ExitVelocity);
	Parms.Impulse = std::move(Impulse);
	Parms.PenetrationDepth = PenetrationDepth;
	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.TraceProjectile.OnTrace
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          StartLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          EndLocation                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATraceProjectile::OnTrace(const struct FVector& StartLocation, const struct FVector& EndLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TraceProjectile", "OnTrace");

	Params::TraceProjectile_OnTrace Parms{};

	Parms.StartLocation = std::move(StartLocation);
	Parms.EndLocation = std::move(EndLocation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function POLYGON.TraceProjectile.OnTrajectoryUpdateReceived
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OldVelocity                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NewVelocity                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATraceProjectile::OnTrajectoryUpdateReceived(const struct FVector& Location, const struct FVector& OldVelocity, const struct FVector& NewVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TraceProjectile", "OnTrajectoryUpdateReceived");

	Params::TraceProjectile_OnTrajectoryUpdateReceived Parms{};

	Parms.Location = std::move(Location);
	Parms.OldVelocity = std::move(OldVelocity);
	Parms.NewVelocity = std::move(NewVelocity);

	UObject::ProcessEvent(Func, &Parms);
}


// Function POLYGON.TraceProjectile.CollisionFilter
// (Native, Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATraceProjectile::CollisionFilter(const struct FHitResult& HitResult) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TraceProjectile", "CollisionFilter");

	Params::TraceProjectile_CollisionFilter Parms{};

	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function POLYGON.TraceProjectile.UpdateVelocity
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintEvent, Const)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          PreviousVelocity                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ATraceProjectile::UpdateVelocity(const struct FVector& Location, const struct FVector& PreviousVelocity, const float DeltaTime) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TraceProjectile", "UpdateVelocity");

	Params::TraceProjectile_UpdateVelocity Parms{};

	Parms.Location = std::move(Location);
	Parms.PreviousVelocity = std::move(PreviousVelocity);
	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function POLYGON.PlayerCoreComponent.GetLevelByProgress
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Progress                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLevelInfo                       ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FLevelInfo UPlayerCoreComponent::GetLevelByProgress(const int32 Progress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerCoreComponent", "GetLevelByProgress");

	Params::PlayerCoreComponent_GetLevelByProgress Parms{};

	Parms.Progress = Progress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function POLYGON.PlayerCoreComponent.GetNextLevelByLevelID
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             LevelID                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLevelInfo                       ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FLevelInfo UPlayerCoreComponent::GetNextLevelByLevelID(const class FName LevelID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerCoreComponent", "GetNextLevelByLevelID");

	Params::PlayerCoreComponent_GetNextLevelByLevelID Parms{};

	Parms.LevelID = LevelID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function POLYGON.PlayerCoreComponent.AddCredits
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Param_AddCredits                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerCoreComponent::AddCredits(int32 Param_AddCredits)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCoreComponent", "AddCredits");

	Params::PlayerCoreComponent_AddCredits Parms{};

	Parms.Param_AddCredits = Param_AddCredits;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.PlayerCoreComponent.NotifyAddedGameScore_client
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// TArray<struct FScoreInfo>               ScoreInfos                                             (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UPlayerCoreComponent::NotifyAddedGameScore_client(const TArray<struct FScoreInfo>& ScoreInfos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCoreComponent", "NotifyAddedGameScore_client");

	Params::PlayerCoreComponent_NotifyAddedGameScore_client Parms{};

	Parms.ScoreInfos = std::move(ScoreInfos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.PlayerCoreComponent.OnRep_TotalProgress
// (Final, Native, Private)

void UPlayerCoreComponent::OnRep_TotalProgress()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCoreComponent", "OnRep_TotalProgress");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.PlayerCoreComponent.Reset
// (Final, Native, Public)

void UPlayerCoreComponent::Reset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCoreComponent", "Reset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.PlayerCoreComponent.UpdatePlayerCombinedInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// TArray<EModifiedData>                   ModifiedData                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           CustomDelegateString                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerCoreComponent::UpdatePlayerCombinedInfo(const TArray<EModifiedData>& ModifiedData, const class FString& CustomDelegateString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCoreComponent", "UpdatePlayerCombinedInfo");

	Params::PlayerCoreComponent_UpdatePlayerCombinedInfo Parms{};

	Parms.ModifiedData = std::move(ModifiedData);
	Parms.CustomDelegateString = std::move(CustomDelegateString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.PlayerCoreComponent.GetCurrentLevelInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FLevelInfo                       ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FLevelInfo UPlayerCoreComponent::GetCurrentLevelInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCoreComponent", "GetCurrentLevelInfo");

	Params::PlayerCoreComponent_GetCurrentLevelInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function POLYGON.PlayerCoreComponent.GetNextLevelInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FLevelInfo                       ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FLevelInfo UPlayerCoreComponent::GetNextLevelInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCoreComponent", "GetNextLevelInfo");

	Params::PlayerCoreComponent_GetNextLevelInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function POLYGON.ChatSystemComponent.SendMessage_Server
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// struct FGameChatMessage                 Message                                                (Parm, NativeAccessSpecifierPublic)

void UChatSystemComponent::SendMessage_Server(const struct FGameChatMessage& Message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChatSystemComponent", "SendMessage_Server");

	Params::ChatSystemComponent_SendMessage_Server Parms{};

	Parms.Message = std::move(Message);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.ChatSystemComponent.SentMessage_Multicast
// (Final, Net, Native, Event, NetMulticast, Private)
// Parameters:
// struct FGameChatMessage                 Message                                                (Parm, NativeAccessSpecifierPublic)

void UChatSystemComponent::SentMessage_Multicast(const struct FGameChatMessage& Message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChatSystemComponent", "SentMessage_Multicast");

	Params::ChatSystemComponent_SentMessage_Multicast Parms{};

	Parms.Message = std::move(Message);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.ClientBackendComponent.IsClientLoggedIn
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UClientBackendComponent::IsClientLoggedIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ClientBackendComponent", "IsClientLoggedIn");

	Params::ClientBackendComponent_IsClientLoggedIn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function POLYGON.ClientBackendComponent.GiveVipLocal
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ID                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UClientBackendComponent::GiveVipLocal(const class FString& ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientBackendComponent", "GiveVipLocal");

	Params::ClientBackendComponent_GiveVipLocal Parms{};

	Parms.ID = std::move(ID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.ClientBackendComponent.SerPlayerExperiments
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPlayFabJsonObject*               Experiments                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UClientBackendComponent::SerPlayerExperiments(class UPlayFabJsonObject* Experiments)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientBackendComponent", "SerPlayerExperiments");

	Params::ClientBackendComponent_SerPlayerExperiments Parms{};

	Parms.Experiments = Experiments;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.ClientBackendComponent.SetPlayerCombinedInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UPlayFabJsonObject*               NewPlayerCombinedInfo                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<EModifiedData>                   ModifiedData                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           CustomDelegateString                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UClientBackendComponent::SetPlayerCombinedInfo(class UPlayFabJsonObject* NewPlayerCombinedInfo, const TArray<EModifiedData>& ModifiedData, const class FString& CustomDelegateString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientBackendComponent", "SetPlayerCombinedInfo");

	Params::ClientBackendComponent_SetPlayerCombinedInfo Parms{};

	Parms.NewPlayerCombinedInfo = NewPlayerCombinedInfo;
	Parms.ModifiedData = std::move(ModifiedData);
	Parms.CustomDelegateString = std::move(CustomDelegateString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.ClientBackendComponent.SetPlayerId
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           NewPlayerMasterId                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UClientBackendComponent::SetPlayerId(const class FString& NewPlayerMasterId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientBackendComponent", "SetPlayerId");

	Params::ClientBackendComponent_SetPlayerId Parms{};

	Parms.NewPlayerMasterId = std::move(NewPlayerMasterId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.ClientBackendComponent.GetPlayerCombinedInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UPlayFabJsonObject*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPlayFabJsonObject* UClientBackendComponent::GetPlayerCombinedInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientBackendComponent", "GetPlayerCombinedInfo");

	Params::ClientBackendComponent_GetPlayerCombinedInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function POLYGON.ClientBackendComponent.GetPlayerExperiments
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UPlayFabJsonObject*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPlayFabJsonObject* UClientBackendComponent::GetPlayerExperiments() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientBackendComponent", "GetPlayerExperiments");

	Params::ClientBackendComponent_GetPlayerExperiments Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function POLYGON.ServerGameInstance.OnGSDKHealthCheck
// (Final, Native, Protected)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UServerGameInstance::OnGSDKHealthCheck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ServerGameInstance", "OnGSDKHealthCheck");

	Params::ServerGameInstance_OnGSDKHealthCheck Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function POLYGON.ServerGameInstance.OnGSDKReadyForPlayers
// (Final, Native, Protected)

void UServerGameInstance::OnGSDKReadyForPlayers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ServerGameInstance", "OnGSDKReadyForPlayers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.ServerGameInstance.OnGSDKServerActive
// (Final, Native, Protected)

void UServerGameInstance::OnGSDKServerActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ServerGameInstance", "OnGSDKServerActive");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.ServerGameInstance.OnGSDKShutdown
// (Final, Native, Protected)

void UServerGameInstance::OnGSDKShutdown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ServerGameInstance", "OnGSDKShutdown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.ClientGameInstance.HandleNetworkFailure
// (Final, Native, Private)
// Parameters:
// class UWorld*                           World                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNetDriver*                       NetDriver                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENetworkFailure                         FailureType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ErrorString                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UClientGameInstance::HandleNetworkFailure(class UWorld* World, class UNetDriver* NetDriver, ENetworkFailure FailureType, const class FString& ErrorString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientGameInstance", "HandleNetworkFailure");

	Params::ClientGameInstance_HandleNetworkFailure Parms{};

	Parms.World = World;
	Parms.NetDriver = NetDriver;
	Parms.FailureType = FailureType;
	Parms.ErrorString = std::move(ErrorString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.ClientGameInstance.SetPlayerCombinedInfo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPlayFabJsonObject*               NewPlayerCombinedInfo                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UClientGameInstance::SetPlayerCombinedInfo(class UPlayFabJsonObject* NewPlayerCombinedInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientGameInstance", "SetPlayerCombinedInfo");

	Params::ClientGameInstance_SetPlayerCombinedInfo Parms{};

	Parms.NewPlayerCombinedInfo = NewPlayerCombinedInfo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.ClientGameInstance.SetPlayerId
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           NewPlayerMasterId                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UClientGameInstance::SetPlayerId(const class FString& NewPlayerMasterId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientGameInstance", "SetPlayerId");

	Params::ClientGameInstance_SetPlayerId Parms{};

	Parms.NewPlayerMasterId = std::move(NewPlayerMasterId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.ClientGameInstance.SetServerTime
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FDateTime                        ServerTime                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UClientGameInstance::SetServerTime(const struct FDateTime& ServerTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientGameInstance", "SetServerTime");

	Params::ClientGameInstance_SetServerTime Parms{};

	Parms.ServerTime = std::move(ServerTime);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.ClientGameInstance.GetPlayerCombinedInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UPlayFabJsonObject*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPlayFabJsonObject* UClientGameInstance::GetPlayerCombinedInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientGameInstance", "GetPlayerCombinedInfo");

	Params::ClientGameInstance_GetPlayerCombinedInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function POLYGON.ClientGameInstance.GetPlayerMasterId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UClientGameInstance::GetPlayerMasterId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientGameInstance", "GetPlayerMasterId");

	Params::ClientGameInstance_GetPlayerMasterId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function POLYGON.ClientGameInstance.GetServerTime
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FDateTime                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FDateTime UClientGameInstance::GetServerTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientGameInstance", "GetServerTime");

	Params::ClientGameInstance_GetServerTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function POLYGON.SquadComponent.OnRep_CooldownCounter
// (Final, Native, Private)

void USquadComponent::OnRep_CooldownCounter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SquadComponent", "OnRep_CooldownCounter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.SquadComponent.OnRep_Members
// (Final, Native, Private)

void USquadComponent::OnRep_Members()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SquadComponent", "OnRep_Members");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.ControlPoint.OnRep_CapturedTeam
// (Final, Native, Private)

void AControlPoint::OnRep_CapturedTeam()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ControlPoint", "OnRep_CapturedTeam");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.ControlPoint.OnRep_IsCapture
// (Final, Native, Private)

void AControlPoint::OnRep_IsCapture()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ControlPoint", "OnRep_IsCapture");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.ControlPoint.ContainsCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AControlPoint::ContainsCharacter(class ACharacter* Character) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ControlPoint", "ContainsCharacter");

	Params::ControlPoint_ContainsCharacter Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function POLYGON.ControlPoint.GetControlPointNameAsOneLetter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString AControlPoint::GetControlPointNameAsOneLetter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ControlPoint", "GetControlPointNameAsOneLetter");

	Params::ControlPoint_GetControlPointNameAsOneLetter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function POLYGON.ControlPoint.GetControlPointNameAsString
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString AControlPoint::GetControlPointNameAsString() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ControlPoint", "GetControlPointNameAsString");

	Params::ControlPoint_GetControlPointNameAsString Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function POLYGON.ControlPoint.OnRep_CapturePointsAlphaTeam
// (Final, Native, Private, Const)

void AControlPoint::OnRep_CapturePointsAlphaTeam() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ControlPoint", "OnRep_CapturePointsAlphaTeam");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.ControlPoint.OnRep_CapturePointsBravoTeam
// (Final, Native, Private, Const)

void AControlPoint::OnRep_CapturePointsBravoTeam() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ControlPoint", "OnRep_CapturePointsBravoTeam");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.DataManagerLibrary.GetDataTableReferences
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataContainerAsset*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataContainerAsset* UDataManagerLibrary::GetDataTableReferences()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DataManagerLibrary", "GetDataTableReferences");

	Params::DataManagerLibrary_GetDataTableReferences Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function POLYGON.EOSPartyId.ToString
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UEOSPartyId::ToString()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EOSPartyId", "ToString");

	Params::EOSPartyId_ToString Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function POLYGON.EOSPartyMemberId.ToString
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UEOSPartyMemberId::ToString()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EOSPartyMemberId", "ToString");

	Params::EOSPartyMemberId_ToString Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function POLYGON.EOSSubsystemAvanced.GetJoinedParties
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UEOSPartyId*>              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UEOSPartyId*> UEOSSubsystemAvanced::GetJoinedParties(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EOSSubsystemAvanced", "GetJoinedParties");

	Params::EOSSubsystemAvanced_GetJoinedParties Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function POLYGON.EOSSubsystemAvanced.GetPartyMembers
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UEOSPartyId*                      PartyId                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UEOSPartyMemberId*>        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UEOSPartyMemberId*> UEOSSubsystemAvanced::GetPartyMembers(const class UObject* WorldContextObject, class UEOSPartyId* PartyId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EOSSubsystemAvanced", "GetPartyMembers");

	Params::EOSSubsystemAvanced_GetPartyMembers Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PartyId = PartyId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function POLYGON.EOSSubsystemAvanced.StartCreateParty
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PartyTypeId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(bool WasSuccessful)>     OnDone                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEOSSubsystemAvanced::StartCreateParty(const class UObject* WorldContextObject, int32 PartyTypeId, TDelegate<void(bool WasSuccessful)> OnDone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EOSSubsystemAvanced", "StartCreateParty");

	Params::EOSSubsystemAvanced_StartCreateParty Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PartyTypeId = PartyTypeId;
	Parms.OnDone = OnDone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.EOSSubsystemAvanced.StartLogin
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TDelegate<void(bool IsSuccessful, const class FString& ErrorMessage)>OnLoginComplete                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEOSSubsystemAvanced::StartLogin(TDelegate<void(bool IsSuccessful, const class FString& ErrorMessage)> OnLoginComplete)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EOSSubsystemAvanced", "StartLogin");

	Params::EOSSubsystemAvanced_StartLogin Parms{};

	Parms.OnLoginComplete = OnLoginComplete;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.EventManagerComponent.AmmoBoxAction
// (Net, Native, Event, Public, NetClient)

void UEventManagerComponent::AmmoBoxAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventManagerComponent", "AmmoBoxAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.EventManagerComponent.OnAmmoBoxAction
// (Event, Public, BlueprintEvent)

void UEventManagerComponent::OnAmmoBoxAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventManagerComponent", "OnAmmoBoxAction");

	UObject::ProcessEvent(Func, nullptr);
}


// Function POLYGON.FOVManagerComponent.HardResetCameraFOV
// (Final, Native, Public, BlueprintCallable)

void UFOVManagerComponent::HardResetCameraFOV()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FOVManagerComponent", "HardResetCameraFOV");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.FOVManagerComponent.HardResetMeshFOV
// (Final, Native, Public, BlueprintCallable)

void UFOVManagerComponent::HardResetMeshFOV()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FOVManagerComponent", "HardResetMeshFOV");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.FOVManagerComponent.SetCameraFOV
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewCameraFOV                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFOVManagerComponent::SetCameraFOV(const float NewCameraFOV)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FOVManagerComponent", "SetCameraFOV");

	Params::FOVManagerComponent_SetCameraFOV Parms{};

	Parms.NewCameraFOV = NewCameraFOV;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.FOVManagerComponent.SetDefaultCameraFOV
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewDefaultCameraFOV                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFOVManagerComponent::SetDefaultCameraFOV(const float NewDefaultCameraFOV)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FOVManagerComponent", "SetDefaultCameraFOV");

	Params::FOVManagerComponent_SetDefaultCameraFOV Parms{};

	Parms.NewDefaultCameraFOV = NewDefaultCameraFOV;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.FOVManagerComponent.SetMeshFOV
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewMeshFOV                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFOVManagerComponent::SetMeshFOV(const float NewMeshFOV)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FOVManagerComponent", "SetMeshFOV");

	Params::FOVManagerComponent_SetMeshFOV Parms{};

	Parms.NewMeshFOV = NewMeshFOV;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.FOVManagerInterface.SetCorrectiveFovMaterial
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    UseFovMaterial                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IFOVManagerInterface::SetCorrectiveFovMaterial(bool UseFovMaterial)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FOVManagerInterface", "SetCorrectiveFovMaterial");

	Params::FOVManagerInterface_SetCorrectiveFovMaterial Parms{};

	Parms.UseFovMaterial = UseFovMaterial;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.GunModulesInfo.FindModule
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FGunModuleInfo>           Array                                                  (Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TSubclassOf<class AItem_Module_General> ModuleClass                                            (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGunModuleInfo                   ReturnValue                                            (Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FGunModuleInfo UGunModulesInfo::FindModule(const TArray<struct FGunModuleInfo>& Array, TSubclassOf<class AItem_Module_General> ModuleClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GunModulesInfo", "FindModule");

	Params::GunModulesInfo_FindModule Parms{};

	Parms.Array = std::move(Array);
	Parms.ModuleClass = ModuleClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function POLYGON.HealthStatsComponent.KillSelf_server
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)

void UHealthStatsComponent::KillSelf_server()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthStatsComponent", "KillSelf_server");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.HealthStatsComponent.OnRep_Health
// (Final, Native, Private)
// Parameters:
// uint8                                   PreviousHealth                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHealthStatsComponent::OnRep_Health(uint8 PreviousHealth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthStatsComponent", "OnRep_Health");

	Params::HealthStatsComponent_OnRep_Health Parms{};

	Parms.PreviousHealth = PreviousHealth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.HealthStatsComponent.OnRep_HealthProtection
// (Final, Native, Private)

void UHealthStatsComponent::OnRep_HealthProtection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthStatsComponent", "OnRep_HealthProtection");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.HealthStatsComponent.GetHealth
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UHealthStatsComponent::GetHealth() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthStatsComponent", "GetHealth");

	Params::HealthStatsComponent_GetHealth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function POLYGON.HealthStatsComponent.GetHealthProtection
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHealthStatsComponent::GetHealthProtection() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthStatsComponent", "GetHealthProtection");

	Params::HealthStatsComponent_GetHealthProtection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function POLYGON.HealthStatsComponent.GetStamina
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UHealthStatsComponent::GetStamina() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthStatsComponent", "GetStamina");

	Params::HealthStatsComponent_GetStamina Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function POLYGON.InspectManagerComponent.DisableInspect
// (Final, Native, Private, BlueprintCallable)

void UInspectManagerComponent::DisableInspect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InspectManagerComponent", "DisableInspect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.InspectManagerComponent.EnableInspect
// (Final, Native, Private, BlueprintCallable)

void UInspectManagerComponent::EnableInspect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InspectManagerComponent", "EnableInspect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.InspectManagerComponent.ResetRotation
// (Final, Native, Public, BlueprintCallable)

void UInspectManagerComponent::ResetRotation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InspectManagerComponent", "ResetRotation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.InspectManagerComponent.SetPivotOffset
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        Offset                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInspectManagerComponent::SetPivotOffset(const struct FVector2D& Offset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InspectManagerComponent", "SetPivotOffset");

	Params::InspectManagerComponent_SetPivotOffset Parms{};

	Parms.Offset = std::move(Offset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.InteractInterface.SetPlayerLooks
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APG_Game_Character*               Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsLooks                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IInteractInterface::SetPlayerLooks(class APG_Game_Character* Character, const bool bIsLooks)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractInterface", "SetPlayerLooks");

	Params::InteractInterface_SetPlayerLooks Parms{};

	Parms.Character = Character;
	Parms.bIsLooks = bIsLooks;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.InteractInterface.StartInteract
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APG_Game_Character*               Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IInteractInterface::StartInteract(class APG_Game_Character* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractInterface", "StartInteract");

	Params::InteractInterface_StartInteract Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.InteractInterface.StopInteract
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APG_Game_Character*               Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IInteractInterface::StopInteract(class APG_Game_Character* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractInterface", "StopInteract");

	Params::InteractInterface_StopInteract Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.InventoryComponent_Base.GetGunBySlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EGunSlot                                GunSlot                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AItem_Gun_General*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AItem_Gun_General* UInventoryComponent_Base::GetGunBySlot(EGunSlot GunSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent_Base", "GetGunBySlot");

	Params::InventoryComponent_Base_GetGunBySlot Parms{};

	Parms.GunSlot = GunSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function POLYGON.InventoryComponent_Base.OnRep_PrimaryGun
// (Native, Protected)
// Parameters:
// class AItem_Gun_General*                OldGun                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryComponent_Base::OnRep_PrimaryGun(class AItem_Gun_General* OldGun)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent_Base", "OnRep_PrimaryGun");

	Params::InventoryComponent_Base_OnRep_PrimaryGun Parms{};

	Parms.OldGun = OldGun;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.InventoryComponent_Base.OnRep_SecondaryGun
// (Native, Protected)
// Parameters:
// class AItem_Gun_General*                OldGun                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryComponent_Base::OnRep_SecondaryGun(class AItem_Gun_General* OldGun)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent_Base", "OnRep_SecondaryGun");

	Params::InventoryComponent_Base_OnRep_SecondaryGun Parms{};

	Parms.OldGun = OldGun;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.InventoryComponent_Base.UpdatePlayerCombinedInfo
// (Native, Protected, HasOutParams)
// Parameters:
// TArray<EModifiedData>                   ModifiedData                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           CustomDelegateString                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryComponent_Base::UpdatePlayerCombinedInfo(const TArray<EModifiedData>& ModifiedData, const class FString& CustomDelegateString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent_Base", "UpdatePlayerCombinedInfo");

	Params::InventoryComponent_Base_UpdatePlayerCombinedInfo Parms{};

	Parms.ModifiedData = std::move(ModifiedData);
	Parms.CustomDelegateString = std::move(CustomDelegateString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.InventoryComponent_Game.AddGrenate_server
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// uint8                                   Number                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryComponent_Game::AddGrenate_server(const uint8 Number)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent_Game", "AddGrenate_server");

	Params::InventoryComponent_Game_AddGrenate_server Parms{};

	Parms.Number = Number;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.InventoryComponent_Game.EquipItems
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FString>                   ItemsInstanceId                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    CallUpdate                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UInventoryComponent_Game::EquipItems(const TArray<class FString>& ItemsInstanceId, const bool CallUpdate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent_Game", "EquipItems");

	Params::InventoryComponent_Game_EquipItems Parms{};

	Parms.ItemsInstanceId = std::move(ItemsInstanceId);
	Parms.CallUpdate = CallUpdate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function POLYGON.InventoryComponent_Game.OnRep_CurrentGun
// (Final, Native, Private)
// Parameters:
// class AItem_Gun_General*                PreviousGun                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryComponent_Game::OnRep_CurrentGun(class AItem_Gun_General* PreviousGun)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent_Game", "OnRep_CurrentGun");

	Params::InventoryComponent_Game_OnRep_CurrentGun Parms{};

	Parms.PreviousGun = PreviousGun;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.InventoryComponent_Game.OnRep_GrenadesNumber
// (Final, Native, Private)

void UInventoryComponent_Game::OnRep_GrenadesNumber()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent_Game", "OnRep_GrenadesNumber");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.InventoryComponent_Game.RequestEquipItems_server
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// TArray<class FString>                   ItemsInstanceId                                        (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UInventoryComponent_Game::RequestEquipItems_server(const TArray<class FString>& ItemsInstanceId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent_Game", "RequestEquipItems_server");

	Params::InventoryComponent_Game_RequestEquipItems_server Parms{};

	Parms.ItemsInstanceId = std::move(ItemsInstanceId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.InventoryComponent_Game.RequestSetGunModules_server
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// class AItem_Gun_General*                GunRef                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ModuleId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGunModuleType                          ModuleType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryComponent_Game::RequestSetGunModules_server(class AItem_Gun_General* GunRef, const class FString& ModuleId, const EGunModuleType ModuleType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent_Game", "RequestSetGunModules_server");

	Params::InventoryComponent_Game_RequestSetGunModules_server Parms{};

	Parms.GunRef = GunRef;
	Parms.ModuleId = std::move(ModuleId);
	Parms.ModuleType = ModuleType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.Item_Grenade_General.NotifyThrow_server
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// struct FVector_NetQuantize              StartPosition                                          (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize              Impulse                                                (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AItem_Grenade_General::NotifyThrow_server(const struct FVector_NetQuantize& StartPosition, const struct FVector_NetQuantize& Impulse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item_Grenade_General", "NotifyThrow_server");

	Params::Item_Grenade_General_NotifyThrow_server Parms{};

	Parms.StartPosition = std::move(StartPosition);
	Parms.Impulse = std::move(Impulse);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.Item_Grenade_General.OnGrenadeThrow
// (Event, Public, BlueprintEvent)

void AItem_Grenade_General::OnGrenadeThrow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item_Grenade_General", "OnGrenadeThrow");

	UObject::ProcessEvent(Func, nullptr);
}


// Function POLYGON.Item_Grenade_General.OnMeshHit
// (Final, Native, Public, HasOutParams, HasDefaults)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AItem_Grenade_General::OnMeshHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item_Grenade_General", "OnMeshHit");

	Params::Item_Grenade_General_OnMeshHit Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.Item_Grenade_General.OnRep_ReplicatedPosition
// (Final, Native, Private)

void AItem_Grenade_General::OnRep_ReplicatedPosition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item_Grenade_General", "OnRep_ReplicatedPosition");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.Item_Gun_General.AddStockAmmo_server
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// int8                                    AddAmmo                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AItem_Gun_General::AddStockAmmo_server(const int8 AddAmmo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item_Gun_General", "AddStockAmmo_server");

	Params::Item_Gun_General_AddStockAmmo_server Parms{};

	Parms.AddAmmo = AddAmmo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.Item_Gun_General.CockBolt_multicast
// (Final, Net, Native, Event, NetMulticast, Private)

void AItem_Gun_General::CockBolt_multicast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item_Gun_General", "CockBolt_multicast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.Item_Gun_General.CockBolt_server
// (Final, Net, Native, Event, Private, NetServer, NetValidate)

void AItem_Gun_General::CockBolt_server()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item_Gun_General", "CockBolt_server");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.Item_Gun_General.GetForwardShot
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AItem_Gun_General::GetForwardShot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item_Gun_General", "GetForwardShot");

	Params::Item_Gun_General_GetForwardShot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function POLYGON.Item_Gun_General.NotifyGrantedModulesDataContainer_client
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class FString                           ItemInstanceId                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AItem_Gun_General::NotifyGrantedModulesDataContainer_client(const class FString& ItemInstanceId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item_Gun_General", "NotifyGrantedModulesDataContainer_client");

	Params::Item_Gun_General_NotifyGrantedModulesDataContainer_client Parms{};

	Parms.ItemInstanceId = std::move(ItemInstanceId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.Item_Gun_General.NotifyGrantedProgressDataContainer_client
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class FString                           ItemInstanceId                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AItem_Gun_General::NotifyGrantedProgressDataContainer_client(const class FString& ItemInstanceId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item_Gun_General", "NotifyGrantedProgressDataContainer_client");

	Params::Item_Gun_General_NotifyGrantedProgressDataContainer_client Parms{};

	Parms.ItemInstanceId = std::move(ItemInstanceId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.Item_Gun_General.NotifyServerHit
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// struct FGunHitOnCharacter               HitOnCharacter                                         (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void AItem_Gun_General::NotifyServerHit(const struct FGunHitOnCharacter& HitOnCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item_Gun_General", "NotifyServerHit");

	Params::Item_Gun_General_NotifyServerHit Parms{};

	Parms.HitOnCharacter = std::move(HitOnCharacter);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.Item_Gun_General.NotifyServerHitWithEnergy
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// struct FGunHitOnCharacter               HitOnCharacter                                         (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// uint8                                   Energy                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AItem_Gun_General::NotifyServerHitWithEnergy(const struct FGunHitOnCharacter& HitOnCharacter, const uint8 Energy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item_Gun_General", "NotifyServerHitWithEnergy");

	Params::Item_Gun_General_NotifyServerHitWithEnergy Parms{};

	Parms.HitOnCharacter = std::move(HitOnCharacter);
	Parms.Energy = Energy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.Item_Gun_General.NotifyServerOfShot
// (Final, Net, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// struct FGunShot                         Param_GunShot                                          (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void AItem_Gun_General::NotifyServerOfShot(const struct FGunShot& Param_GunShot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item_Gun_General", "NotifyServerOfShot");

	Params::Item_Gun_General_NotifyServerOfShot Parms{};

	Parms.Param_GunShot = std::move(Param_GunShot);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.Item_Gun_General.NotifyServerTraceHit
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// struct FGunHitOnCharacter               HitOnCharacter                                         (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void AItem_Gun_General::NotifyServerTraceHit(const struct FGunHitOnCharacter& HitOnCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item_Gun_General", "NotifyServerTraceHit");

	Params::Item_Gun_General_NotifyServerTraceHit Parms{};

	Parms.HitOnCharacter = std::move(HitOnCharacter);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.Item_Gun_General.OnRep_CallHardReset
// (Final, Native, Private)
// Parameters:
// uint8                                   PreviousValue                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AItem_Gun_General::OnRep_CallHardReset(uint8 PreviousValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item_Gun_General", "OnRep_CallHardReset");

	Params::Item_Gun_General_OnRep_CallHardReset Parms{};

	Parms.PreviousValue = PreviousValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.Item_Gun_General.OnRep_CurrentGunModuleClasses
// (Final, Native, Private)

void AItem_Gun_General::OnRep_CurrentGunModuleClasses()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item_Gun_General", "OnRep_CurrentGunModuleClasses");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.Item_Gun_General.OnRep_CurrentStockAmmo
// (Final, Native, Private)

void AItem_Gun_General::OnRep_CurrentStockAmmo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item_Gun_General", "OnRep_CurrentStockAmmo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.Item_Gun_General.OnRep_GunHitOfShortShot
// (Final, Native, Private)
// Parameters:
// struct FVector_NetQuantize              PreviousValue                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AItem_Gun_General::OnRep_GunHitOfShortShot(const struct FVector_NetQuantize& PreviousValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item_Gun_General", "OnRep_GunHitOfShortShot");

	Params::Item_Gun_General_OnRep_GunHitOfShortShot Parms{};

	Parms.PreviousValue = std::move(PreviousValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.Item_Gun_General.OnRep_GunShot
// (Final, Native, Private)
// Parameters:
// struct FGunShot                         PreviousShot                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)

void AItem_Gun_General::OnRep_GunShot(const struct FGunShot& PreviousShot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item_Gun_General", "OnRep_GunShot");

	Params::Item_Gun_General_OnRep_GunShot Parms{};

	Parms.PreviousShot = std::move(PreviousShot);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.Item_Gun_General.OnRep_ReloadCaller
// (Final, Native, Private)
// Parameters:
// uint8                                   PreviousValue                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AItem_Gun_General::OnRep_ReloadCaller(uint8 PreviousValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item_Gun_General", "OnRep_ReloadCaller");

	Params::Item_Gun_General_OnRep_ReloadCaller Parms{};

	Parms.PreviousValue = PreviousValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.Item_Gun_General.OnSetPlayerState
// (Final, Native, Private)

void AItem_Gun_General::OnSetPlayerState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item_Gun_General", "OnSetPlayerState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.Item_Gun_General.RequestReload_server
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// uint8                                   CurrentNumberAmmo                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AItem_Gun_General::RequestReload_server(uint8 CurrentNumberAmmo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item_Gun_General", "RequestReload_server");

	Params::Item_Gun_General_RequestReload_server Parms{};

	Parms.CurrentNumberAmmo = CurrentNumberAmmo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.Item_Gun_General.SetGunModules
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// class UPlayFabJsonObject*               Modules                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AItem_Gun_General::SetGunModules(class UPlayFabJsonObject* Modules)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item_Gun_General", "SetGunModules");

	Params::Item_Gun_General_SetGunModules Parms{};

	Parms.Modules = Modules;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.Item_Gun_General.UpdateAmmoCount_server
// (Final, Net, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// uint8                                   CurrentNumberAmmo                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AItem_Gun_General::UpdateAmmoCount_server(uint8 CurrentNumberAmmo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item_Gun_General", "UpdateAmmoCount_server");

	Params::Item_Gun_General_UpdateAmmoCount_server Parms{};

	Parms.CurrentNumberAmmo = CurrentNumberAmmo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.Item_Gun_General.UpdatePlayerCombinedInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// TArray<EModifiedData>                   ModifiedData                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           CustomDelegateString                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AItem_Gun_General::UpdatePlayerCombinedInfo(const TArray<EModifiedData>& ModifiedData, const class FString& CustomDelegateString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item_Gun_General", "UpdatePlayerCombinedInfo");

	Params::Item_Gun_General_UpdatePlayerCombinedInfo Parms{};

	Parms.ModifiedData = std::move(ModifiedData);
	Parms.CustomDelegateString = std::move(CustomDelegateString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.Item_Gun_General.GetCurrentStockAmmo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AItem_Gun_General::GetCurrentStockAmmo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item_Gun_General", "GetCurrentStockAmmo");

	Params::Item_Gun_General_GetCurrentStockAmmo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function POLYGON.Item_Gun_General.GetItemReference
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UPlayFabJsonObject*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPlayFabJsonObject* AItem_Gun_General::GetItemReference() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item_Gun_General", "GetItemReference");

	Params::Item_Gun_General_GetItemReference Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function POLYGON.Item_Module_Flashlight.OnChangeEnableState
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bPlaySound                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AItem_Module_Flashlight::OnChangeEnableState(const bool bPlaySound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item_Module_Flashlight", "OnChangeEnableState");

	Params::Item_Module_Flashlight_OnChangeEnableState Parms{};

	Parms.bPlaySound = bPlaySound;

	UObject::ProcessEvent(Func, &Parms);
}


// Function POLYGON.Item_Module_Flashlight.OnRep_IsEnable
// (Final, Native, Protected)
// Parameters:
// bool                                    OldState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AItem_Module_Flashlight::OnRep_IsEnable(bool OldState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item_Module_Flashlight", "OnRep_IsEnable");

	Params::Item_Module_Flashlight_OnRep_IsEnable Parms{};

	Parms.OldState = OldState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.Item_Module_Flashlight.OnSetCurrentGun
// (Final, Native, Private)
// Parameters:
// class AItem_Gun_General*                PreviousGun                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AItem_Module_Flashlight::OnSetCurrentGun(class AItem_Gun_General* PreviousGun)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item_Module_Flashlight", "OnSetCurrentGun");

	Params::Item_Module_Flashlight_OnSetCurrentGun Parms{};

	Parms.PreviousGun = PreviousGun;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.Item_Module_Flashlight.SetFlashlightEnable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsEnable                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCallOnServer                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AItem_Module_Flashlight::SetFlashlightEnable(const bool IsEnable, bool bCallOnServer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item_Module_Flashlight", "SetFlashlightEnable");

	Params::Item_Module_Flashlight_SetFlashlightEnable Parms{};

	Parms.IsEnable = IsEnable;
	Parms.bCallOnServer = bCallOnServer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.Item_Module_Flashlight.SetFlashlightEnable_server
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// bool                                    IsEnable                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AItem_Module_Flashlight::SetFlashlightEnable_server(const bool IsEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item_Module_Flashlight", "SetFlashlightEnable_server");

	Params::Item_Module_Flashlight_SetFlashlightEnable_server Parms{};

	Parms.IsEnable = IsEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.Item_Module_Optic.ToggleAiming
// (BlueprintCosmetic, Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsAiming                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AItem_Module_Optic::ToggleAiming(const bool IsAiming)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item_Module_Optic", "ToggleAiming");

	Params::Item_Module_Optic_ToggleAiming Parms{};

	Parms.IsAiming = IsAiming;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.PG_FunctionLibraryKit.ConfigureGameAnalyticsUserId
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           UserId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPG_FunctionLibraryKit::ConfigureGameAnalyticsUserId(const class FString& UserId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PG_FunctionLibraryKit", "ConfigureGameAnalyticsUserId");

	Params::PG_FunctionLibraryKit_ConfigureGameAnalyticsUserId Parms{};

	Parms.UserId = std::move(UserId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.PG_FunctionLibraryKit.ExitGame
// (Final, Native, Static, Public, BlueprintCallable)

void UPG_FunctionLibraryKit::ExitGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PG_FunctionLibraryKit", "ExitGame");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.PG_FunctionLibraryKit.GetBuildNumber
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UPG_FunctionLibraryKit::GetBuildNumber()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PG_FunctionLibraryKit", "GetBuildNumber");

	Params::PG_FunctionLibraryKit_GetBuildNumber Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function POLYGON.PG_FunctionLibraryKit.GetProjectVersion
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UPG_FunctionLibraryKit::GetProjectVersion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PG_FunctionLibraryKit", "GetProjectVersion");

	Params::PG_FunctionLibraryKit_GetProjectVersion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function POLYGON.PG_FunctionLibraryKit.GetRateScale
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimSequenceBase*                AnimationSequenceBase                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPG_FunctionLibraryKit::GetRateScale(const class UAnimSequenceBase* AnimationSequenceBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PG_FunctionLibraryKit", "GetRateScale");

	Params::PG_FunctionLibraryKit_GetRateScale Parms{};

	Parms.AnimationSequenceBase = AnimationSequenceBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function POLYGON.PG_FunctionLibraryKit.GetRegionEnum
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           RegionName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAzureRegion                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EAzureRegion UPG_FunctionLibraryKit::GetRegionEnum(const class FString& RegionName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PG_FunctionLibraryKit", "GetRegionEnum");

	Params::PG_FunctionLibraryKit_GetRegionEnum Parms{};

	Parms.RegionName = std::move(RegionName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function POLYGON.PG_FunctionLibraryKit.ParseOption
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           Options                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Key                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Separator                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UPG_FunctionLibraryKit::ParseOption(const class FString& Options, const class FString& Key, const class FString& Separator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PG_FunctionLibraryKit", "ParseOption");

	Params::PG_FunctionLibraryKit_ParseOption Parms{};

	Parms.Options = std::move(Options);
	Parms.Key = std::move(Key);
	Parms.Separator = std::move(Separator);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function POLYGON.PG_FunctionLibraryKit.StartSessionGameAnalytics
// (Final, Native, Static, Public, BlueprintCallable)

void UPG_FunctionLibraryKit::StartSessionGameAnalytics()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PG_FunctionLibraryKit", "StartSessionGameAnalytics");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.PG_GameInstance.GetClientGameInstance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UClientGameInstance*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UClientGameInstance* UPG_GameInstance::GetClientGameInstance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_GameInstance", "GetClientGameInstance");

	Params::PG_GameInstance_GetClientGameInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function POLYGON.PG_GameInstance.GetServerGameInstance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UServerGameInstance*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UServerGameInstance* UPG_GameInstance::GetServerGameInstance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_GameInstance", "GetServerGameInstance");

	Params::PG_GameInstance_GetServerGameInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function POLYGON.PG_GameMode_Game.LoginPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APG_PlayerController_Game*        PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           PlayerMasterId                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APG_GameMode_Game::LoginPlayer(class APG_PlayerController_Game* PlayerController, const class FString& PlayerMasterId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_GameMode_Game", "LoginPlayer");

	Params::PG_GameMode_Game_LoginPlayer Parms{};

	Parms.PlayerController = PlayerController;
	Parms.PlayerMasterId = std::move(PlayerMasterId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.PG_GameState_Game.NotifyPlayerWasKicked
// (Net, Native, Event, NetMulticast, Public)
// Parameters:
// class FString                           badGuyName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNameWasOptimized                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APG_GameState_Game::NotifyPlayerWasKicked(const class FString& badGuyName, const bool bNameWasOptimized)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_GameState_Game", "NotifyPlayerWasKicked");

	Params::PG_GameState_Game_NotifyPlayerWasKicked Parms{};

	Parms.badGuyName = std::move(badGuyName);
	Parms.bNameWasOptimized = bNameWasOptimized;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.PG_GameState_Game.SetCanMovePlayers
// (Final, Native, Public)
// Parameters:
// bool                                    NewMoveState                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APG_GameState_Game::SetCanMovePlayers(const bool NewMoveState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_GameState_Game", "SetCanMovePlayers");

	Params::PG_GameState_Game_SetCanMovePlayers Parms{};

	Parms.NewMoveState = NewMoveState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.PG_GameState_Game.GetGameTimer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 APG_GameState_Game::GetGameTimer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_GameState_Game", "GetGameTimer");

	Params::PG_GameState_Game_GetGameTimer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function POLYGON.PG_GameState_Game.GetMaxScoreForWin
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 APG_GameState_Game::GetMaxScoreForWin() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_GameState_Game", "GetMaxScoreForWin");

	Params::PG_GameState_Game_GetMaxScoreForWin Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function POLYGON.PG_GameState_Game.GetScoreAlphaTeam
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 APG_GameState_Game::GetScoreAlphaTeam() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_GameState_Game", "GetScoreAlphaTeam");

	Params::PG_GameState_Game_GetScoreAlphaTeam Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function POLYGON.PG_GameState_Game.GetScoreBravoTeam
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 APG_GameState_Game::GetScoreBravoTeam() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_GameState_Game", "GetScoreBravoTeam");

	Params::PG_GameState_Game_GetScoreBravoTeam Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function POLYGON.PG_GameState_Game.OnRep_CanMovePlayers
// (Final, Native, Private, Const)

void APG_GameState_Game::OnRep_CanMovePlayers() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_GameState_Game", "OnRep_CanMovePlayers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.PG_GameState_Game.OnRep_GameState
// (Final, Native, Private, Const)

void APG_GameState_Game::OnRep_GameState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_GameState_Game", "OnRep_GameState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.PG_GameState_Game.OnRep_GameTimer
// (Final, Native, Private, Const)

void APG_GameState_Game::OnRep_GameTimer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_GameState_Game", "OnRep_GameTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.PG_GameState_Game.OnRep_Players
// (Final, Native, Private, Const)

void APG_GameState_Game::OnRep_Players() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_GameState_Game", "OnRep_Players");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.PG_GameState_Game.OnRep_ScoreAlphaTeam
// (Final, Native, Private, Const)

void APG_GameState_Game::OnRep_ScoreAlphaTeam() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_GameState_Game", "OnRep_ScoreAlphaTeam");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.PG_GameState_Game.OnRep_ScoreBravoTeam
// (Final, Native, Private, Const)

void APG_GameState_Game::OnRep_ScoreBravoTeam() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_GameState_Game", "OnRep_ScoreBravoTeam");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.PG_GameState_Game.OnRep_ServerFps
// (Final, Native, Private, Const)

void APG_GameState_Game::OnRep_ServerFps() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_GameState_Game", "OnRep_ServerFps");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.PG_GameState_Game.OnRep_TeamAlpha
// (Final, Native, Private, Const)

void APG_GameState_Game::OnRep_TeamAlpha() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_GameState_Game", "OnRep_TeamAlpha");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.PG_GameState_Game.OnRep_TeamBravo
// (Final, Native, Private, Const)

void APG_GameState_Game::OnRep_TeamBravo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_GameState_Game", "OnRep_TeamBravo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.PG_GameState_Game.OnRep_WinningTeam
// (Final, Native, Private, Const)

void APG_GameState_Game::OnRep_WinningTeam() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_GameState_Game", "OnRep_WinningTeam");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.PG_Game_Character.ActionWhenGunHit_client
// (Final, Net, Native, Event, Private, NetClient)
// Parameters:
// class APG_Game_Character*               CharacterInstigator                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   HitBoneIndex                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APG_Game_Character::ActionWhenGunHit_client(class APG_Game_Character* CharacterInstigator, const uint8 HitBoneIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_Game_Character", "ActionWhenGunHit_client");

	Params::PG_Game_Character_ActionWhenGunHit_client Parms{};

	Parms.CharacterInstigator = CharacterInstigator;
	Parms.HitBoneIndex = HitBoneIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.PG_Game_Character.ActionWhenTakeDamage_client
// (Final, Net, Native, Event, Private, NetClient)
// Parameters:
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APG_Game_Character::ActionWhenTakeDamage_client(class AActor* DamageCauser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_Game_Character", "ActionWhenTakeDamage_client");

	Params::PG_Game_Character_ActionWhenTakeDamage_client Parms{};

	Parms.DamageCauser = DamageCauser;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.PG_Game_Character.CameraNeutralizationEffectEvent
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   Damage                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APG_Game_Character::CameraNeutralizationEffectEvent(const float Damage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_Game_Character", "CameraNeutralizationEffectEvent");

	Params::PG_Game_Character_CameraNeutralizationEffectEvent Parms{};

	Parms.Damage = Damage;

	UObject::ProcessEvent(Func, &Parms);
}


// Function POLYGON.PG_Game_Character.ChangeIsAlive
// (Final, Native, Public)

void APG_Game_Character::ChangeIsAlive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_Game_Character", "ChangeIsAlive");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.PG_Game_Character.DeathEvent
// (Event, Public, BlueprintEvent)
// Parameters:
// class APG_PlayerState_Game*             Killer                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPlayerDeathType                        DeathType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APG_Game_Character::DeathEvent(class APG_PlayerState_Game* Killer, EPlayerDeathType DeathType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_Game_Character", "DeathEvent");

	Params::PG_Game_Character_DeathEvent Parms{};

	Parms.Killer = Killer;
	Parms.DeathType = DeathType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function POLYGON.PG_Game_Character.EventTakeDamage
// (Event, Protected, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          Origin                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APG_Game_Character::EventTakeDamage(const struct FVector& Origin)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_Game_Character", "EventTakeDamage");

	Params::PG_Game_Character_EventTakeDamage Parms{};

	Parms.Origin = std::move(Origin);

	UObject::ProcessEvent(Func, &Parms);
}


// Function POLYGON.PG_Game_Character.HitAtProtectedCharacter
// (Event, Public, BlueprintEvent)

void APG_Game_Character::HitAtProtectedCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_Game_Character", "HitAtProtectedCharacter");

	UObject::ProcessEvent(Func, nullptr);
}


// Function POLYGON.PG_Game_Character.LeanBody_server
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// int8                                    Param_LeanBodyAlpha                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APG_Game_Character::LeanBody_server(const int8 Param_LeanBodyAlpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_Game_Character", "LeanBody_server");

	Params::PG_Game_Character_LeanBody_server Parms{};

	Parms.Param_LeanBodyAlpha = Param_LeanBodyAlpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.PG_Game_Character.NotifyDeath_multicast
// (Net, Native, Event, NetMulticast, Public)
// Parameters:
// class APG_PlayerState_Game*             Killer                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPlayerDeathType                        DeathType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APG_Game_Character::NotifyDeath_multicast(class APG_PlayerState_Game* Killer, EPlayerDeathType DeathType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_Game_Character", "NotifyDeath_multicast");

	Params::PG_Game_Character_NotifyDeath_multicast Parms{};

	Parms.Killer = Killer;
	Parms.DeathType = DeathType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.PG_Game_Character.NotifyDeathWithImpulse_multicast
// (Net, Native, Event, NetMulticast, Public)
// Parameters:
// class APG_PlayerState_Game*             Killer                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPlayerDeathType                        DeathType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize              Impulse                                                (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   BoneIndex                                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APG_Game_Character::NotifyDeathWithImpulse_multicast(class APG_PlayerState_Game* Killer, EPlayerDeathType DeathType, const struct FVector_NetQuantize& Impulse, const uint8& BoneIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_Game_Character", "NotifyDeathWithImpulse_multicast");

	Params::PG_Game_Character_NotifyDeathWithImpulse_multicast Parms{};

	Parms.Killer = Killer;
	Parms.DeathType = DeathType;
	Parms.Impulse = std::move(Impulse);
	Parms.BoneIndex = BoneIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.PG_Game_Character.OnRep_PlayerAction
// (Final, Native, Private)
// Parameters:
// EPlayerAction                           PreviousAction                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APG_Game_Character::OnRep_PlayerAction(EPlayerAction PreviousAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_Game_Character", "OnRep_PlayerAction");

	Params::PG_Game_Character_OnRep_PlayerAction Parms{};

	Parms.PreviousAction = PreviousAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.PG_Game_Character.OnRep_RespawnCounter
// (Final, Native, Private)
// Parameters:
// uint8                                   PreviousValue                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APG_Game_Character::OnRep_RespawnCounter(uint8 PreviousValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_Game_Character", "OnRep_RespawnCounter");

	Params::PG_Game_Character_OnRep_RespawnCounter Parms{};

	Parms.PreviousValue = PreviousValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.PG_Game_Character.PlayerLooks
// (Final, BlueprintAuthorityOnly, Native, Private)

void APG_Game_Character::PlayerLooks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_Game_Character", "PlayerLooks");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.PG_Game_Character.Respawn
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void APG_Game_Character::Respawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_Game_Character", "Respawn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.PG_Game_Character.Respawn_client
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// struct FVector_NetQuantize              NewLocation                                            (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantizeNormal        NewRotator                                             (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APG_Game_Character::Respawn_client(const struct FVector_NetQuantize& NewLocation, const struct FVector_NetQuantizeNormal& NewRotator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_Game_Character", "Respawn_client");

	Params::PG_Game_Character_Respawn_client Parms{};

	Parms.NewLocation = std::move(NewLocation);
	Parms.NewRotator = std::move(NewRotator);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.PG_Game_Character.SetIsSprinting_server
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// bool                                    NewState                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APG_Game_Character::SetIsSprinting_server(const bool NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_Game_Character", "SetIsSprinting_server");

	Params::PG_Game_Character_SetIsSprinting_server Parms{};

	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.PG_Game_Character.SetNeutralizationVignetteImpact
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewNeutralizationVignetteImpact                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APG_Game_Character::SetNeutralizationVignetteImpact(const float NewNeutralizationVignetteImpact)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_Game_Character", "SetNeutralizationVignetteImpact");

	Params::PG_Game_Character_SetNeutralizationVignetteImpact Parms{};

	Parms.NewNeutralizationVignetteImpact = NewNeutralizationVignetteImpact;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.PG_Game_Character.StartInteractWithObject
// (Final, Native, Protected)

void APG_Game_Character::StartInteractWithObject()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_Game_Character", "StartInteractWithObject");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.PG_Game_Character.StartInteractWithObject_server
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// class AActor*                           InteractActor                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APG_Game_Character::StartInteractWithObject_server(class AActor* InteractActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_Game_Character", "StartInteractWithObject_server");

	Params::PG_Game_Character_StartInteractWithObject_server Parms{};

	Parms.InteractActor = InteractActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.PG_Game_Character.StartShooting
// (Event, Public, BlueprintEvent)

void APG_Game_Character::StartShooting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_Game_Character", "StartShooting");

	UObject::ProcessEvent(Func, nullptr);
}


// Function POLYGON.PG_Game_Character.StopInteractWithObject
// (Final, Native, Protected)

void APG_Game_Character::StopInteractWithObject()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_Game_Character", "StopInteractWithObject");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.PG_Game_Character.StopInteractWithObject_server
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)

void APG_Game_Character::StopInteractWithObject_server()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_Game_Character", "StopInteractWithObject_server");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.PG_Game_Character.GetActiveCamera
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCameraComponent*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCameraComponent* APG_Game_Character::GetActiveCamera() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_Game_Character", "GetActiveCamera");

	Params::PG_Game_Character_GetActiveCamera Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function POLYGON.PG_Game_Character.GetIsSprinting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APG_Game_Character::GetIsSprinting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_Game_Character", "GetIsSprinting");

	Params::PG_Game_Character_GetIsSprinting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function POLYGON.PG_Game_Character.GetNeutralizationVignetteImpact
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float APG_Game_Character::GetNeutralizationVignetteImpact() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_Game_Character", "GetNeutralizationVignetteImpact");

	Params::PG_Game_Character_GetNeutralizationVignetteImpact Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function POLYGON.PG_Game_Character.GetPlayerAction
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPlayerAction                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPlayerAction APG_Game_Character::GetPlayerAction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_Game_Character", "GetPlayerAction");

	Params::PG_Game_Character_GetPlayerAction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function POLYGON.PG_Game_Character.GetTeam
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETeam                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETeam APG_Game_Character::GetTeam() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_Game_Character", "GetTeam");

	Params::PG_Game_Character_GetTeam Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function POLYGON.PG_BeaconClient.ConnectToServer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           IP                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   BeaconPort                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(bool bWasSuccessful)>    OnConnectedStateChange                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APG_BeaconClient::ConnectToServer(const class FString& IP, const int32 BeaconPort, TDelegate<void(bool bWasSuccessful)> OnConnectedStateChange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_BeaconClient", "ConnectToServer");

	Params::PG_BeaconClient_ConnectToServer Parms{};

	Parms.IP = std::move(IP);
	Parms.BeaconPort = BeaconPort;
	Parms.OnConnectedStateChange = OnConnectedStateChange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function POLYGON.PG_BeaconClient.LeaveQueue
// (Final, Native, Public, BlueprintCallable)

void APG_BeaconClient::LeaveQueue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_BeaconClient", "LeaveQueue");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.PG_BeaconClient.RequestReserveSlot
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FUniqueNetIdRepl>         UnequeIds                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    IsUsedMatchmaker                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(uint8 Payload)>          OnResponseReserveSlot                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(uint8 Number)>           OnPutInQueue                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APG_BeaconClient::RequestReserveSlot(const TArray<struct FUniqueNetIdRepl>& UnequeIds, const bool IsUsedMatchmaker, TDelegate<void(uint8 Payload)> OnResponseReserveSlot, TDelegate<void(uint8 Number)> OnPutInQueue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_BeaconClient", "RequestReserveSlot");

	Params::PG_BeaconClient_RequestReserveSlot Parms{};

	Parms.UnequeIds = std::move(UnequeIds);
	Parms.IsUsedMatchmaker = IsUsedMatchmaker;
	Parms.OnResponseReserveSlot = OnResponseReserveSlot;
	Parms.OnPutInQueue = OnPutInQueue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.PG_BeaconClient.RequestReserveSlot_server
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// TArray<struct FUniqueNetIdRepl>         UnequeIds                                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    IsUsedMatchmaker                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APG_BeaconClient::RequestReserveSlot_server(const TArray<struct FUniqueNetIdRepl>& UnequeIds, const bool IsUsedMatchmaker)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_BeaconClient", "RequestReserveSlot_server");

	Params::PG_BeaconClient_RequestReserveSlot_server Parms{};

	Parms.UnequeIds = std::move(UnequeIds);
	Parms.IsUsedMatchmaker = IsUsedMatchmaker;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.PG_BeaconClient.ResponseReserveSlot_client
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// uint8                                   Payload                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APG_BeaconClient::ResponseReserveSlot_client(const uint8 Payload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_BeaconClient", "ResponseReserveSlot_client");

	Params::PG_BeaconClient_ResponseReserveSlot_client Parms{};

	Parms.Payload = Payload;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.PG_BeaconClient.SendNumberInQueue_client
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// uint8                                   Number                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APG_BeaconClient::SendNumberInQueue_client(const uint8 Number)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_BeaconClient", "SendNumberInQueue_client");

	Params::PG_BeaconClient_SendNumberInQueue_client Parms{};

	Parms.Number = Number;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.PG_PlayerController_Base.GetMouseSensitivityAimingValue
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float APG_PlayerController_Base::GetMouseSensitivityAimingValue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PG_PlayerController_Base", "GetMouseSensitivityAimingValue");

	Params::PG_PlayerController_Base_GetMouseSensitivityAimingValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function POLYGON.PG_PlayerController_Base.GetMouseSensitivityValue
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float APG_PlayerController_Base::GetMouseSensitivityValue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PG_PlayerController_Base", "GetMouseSensitivityValue");

	Params::PG_PlayerController_Base_GetMouseSensitivityValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function POLYGON.PG_PlayerController_Base.IsInvertMouse
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APG_PlayerController_Base::IsInvertMouse()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PG_PlayerController_Base", "IsInvertMouse");

	Params::PG_PlayerController_Base_IsInvertMouse Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function POLYGON.PG_PlayerController_Base.ShowError
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FText                             ErrorMessage                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             ErrorDetails                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void APG_PlayerController_Base::ShowError(const class FText& ErrorMessage, const class FText& ErrorDetails)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_PlayerController_Base", "ShowError");

	Params::PG_PlayerController_Base_ShowError Parms{};

	Parms.ErrorMessage = std::move(ErrorMessage);
	Parms.ErrorDetails = std::move(ErrorDetails);

	UObject::ProcessEvent(Func, &Parms);
}


// Function POLYGON.PG_PlayerController_Game.DisplayMessageToChatEvent
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FGameChatMessage                 Message                                                (Parm, NativeAccessSpecifierPublic)

void APG_PlayerController_Game::DisplayMessageToChatEvent(const struct FGameChatMessage& Message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_PlayerController_Game", "DisplayMessageToChatEvent");

	Params::PG_PlayerController_Game_DisplayMessageToChatEvent Parms{};

	Parms.Message = std::move(Message);

	UObject::ProcessEvent(Func, &Parms);
}


// Function POLYGON.PG_PlayerController_Game.LoginPlayer_server
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// class FString                           PlayerMasterId                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APG_PlayerController_Game::LoginPlayer_server(const class FString& PlayerMasterId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_PlayerController_Game", "LoginPlayer_server");

	Params::PG_PlayerController_Game_LoginPlayer_server Parms{};

	Parms.PlayerMasterId = std::move(PlayerMasterId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.PG_PlayerController_Game.OnRep_DeployIsAvailable
// (Final, Native, Private)

void APG_PlayerController_Game::OnRep_DeployIsAvailable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_PlayerController_Game", "OnRep_DeployIsAvailable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.PG_PlayerController_Game.RequestSpawnOnBase_server
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)

void APG_PlayerController_Game::RequestSpawnOnBase_server()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_PlayerController_Game", "RequestSpawnOnBase_server");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.PG_PlayerController_Game.RequestSpawnOnControlPoint_server
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// EControlPoint                           SpawnToControlPoint                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APG_PlayerController_Game::RequestSpawnOnControlPoint_server(EControlPoint SpawnToControlPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_PlayerController_Game", "RequestSpawnOnControlPoint_server");

	Params::PG_PlayerController_Game_RequestSpawnOnControlPoint_server Parms{};

	Parms.SpawnToControlPoint = SpawnToControlPoint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.PG_PlayerController_Game.RequestSpawnOnSquadMember_server
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// class APG_PlayerState_Game*             SquadMember                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APG_PlayerController_Game::RequestSpawnOnSquadMember_server(class APG_PlayerState_Game* SquadMember)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_PlayerController_Game", "RequestSpawnOnSquadMember_server");

	Params::PG_PlayerController_Game_RequestSpawnOnSquadMember_server Parms{};

	Parms.SquadMember = SquadMember;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.PG_PlayerController_Game.SetVisibleLoadingScreen
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsVisible                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APG_PlayerController_Game::SetVisibleLoadingScreen(const bool IsVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_PlayerController_Game", "SetVisibleLoadingScreen");

	Params::PG_PlayerController_Game_SetVisibleLoadingScreen Parms{};

	Parms.IsVisible = IsVisible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function POLYGON.PG_PlayerController_Game.StartInteraction_Client
// (Net, Native, Event, Public, NetClient)
// Parameters:
// float                                   InteractionTime                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APG_PlayerController_Game::StartInteraction_Client(const float InteractionTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_PlayerController_Game", "StartInteraction_Client");

	Params::PG_PlayerController_Game_StartInteraction_Client Parms{};

	Parms.InteractionTime = InteractionTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.PG_PlayerController_Game.StartInteractionEvent
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   InteractionTime                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APG_PlayerController_Game::StartInteractionEvent(const float InteractionTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_PlayerController_Game", "StartInteractionEvent");

	Params::PG_PlayerController_Game_StartInteractionEvent Parms{};

	Parms.InteractionTime = InteractionTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function POLYGON.PG_PlayerController_Game.StopInteraction_Client
// (Net, Native, Event, Public, NetClient)

void APG_PlayerController_Game::StopInteraction_Client()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_PlayerController_Game", "StopInteraction_Client");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.PG_PlayerController_Game.StopInteractionEvent
// (Event, Protected, BlueprintEvent)

void APG_PlayerController_Game::StopInteractionEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_PlayerController_Game", "StopInteractionEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function POLYGON.PG_PlayerController_Game.VoteKick
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// class APG_PlayerState_Game*             badGuy                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APG_PlayerController_Game::VoteKick(class APG_PlayerState_Game* badGuy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PG_PlayerController_Game", "VoteKick");

	Params::PG_PlayerController_Game_VoteKick Parms{};

	Parms.badGuy = badGuy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.SupportBox.OnCoverageBeginOverlap
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    FromSweep                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ASupportBox::OnCoverageBeginOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool FromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SupportBox", "OnCoverageBeginOverlap");

	Params::SupportBox_OnCoverageBeginOverlap Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.FromSweep = FromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.SupportBox.OnCoverageEndOverlap
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASupportBox::OnCoverageEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SupportBox", "OnCoverageEndOverlap");

	Params::SupportBox_OnCoverageEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.WeaponComponent.NotifyServerThrowGrenade
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)

void UWeaponComponent::NotifyServerThrowGrenade()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponComponent", "NotifyServerThrowGrenade");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.WeaponComponent.OnRep_IsAiming
// (Final, Native, Private)

void UWeaponComponent::OnRep_IsAiming()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponComponent", "OnRep_IsAiming");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.WeaponComponent.OnSetCurrentGun
// (Final, Native, Private)
// Parameters:
// class AItem_Gun_General*                OldCurrentGun                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponComponent::OnSetCurrentGun(class AItem_Gun_General* OldCurrentGun)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponComponent", "OnSetCurrentGun");

	Params::WeaponComponent_OnSetCurrentGun Parms{};

	Parms.OldCurrentGun = OldCurrentGun;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.WeaponComponent.OnSetPlayerState
// (Final, Native, Private)

void UWeaponComponent::OnSetPlayerState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponComponent", "OnSetPlayerState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.WeaponComponent.OnSetPrimaryGun
// (Final, Native, Private)
// Parameters:
// class AItem_Gun_General*                OldGun                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponComponent::OnSetPrimaryGun(class AItem_Gun_General* OldGun)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponComponent", "OnSetPrimaryGun");

	Params::WeaponComponent_OnSetPrimaryGun Parms{};

	Parms.OldGun = OldGun;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.WeaponComponent.OnSetSecondaryGun
// (Final, Native, Private)
// Parameters:
// class AItem_Gun_General*                OldGun                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponComponent::OnSetSecondaryGun(class AItem_Gun_General* OldGun)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponComponent", "OnSetSecondaryGun");

	Params::WeaponComponent_OnSetSecondaryGun Parms{};

	Parms.OldGun = OldGun;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.WeaponComponent.SelectGunSlot_server
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// uint8                                   Slot                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponComponent::SelectGunSlot_server(const uint8 Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponComponent", "SelectGunSlot_server");

	Params::WeaponComponent_SelectGunSlot_server Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.WeaponComponent.SetGunRecoilAlpha_Roll
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewRollRecoil                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponComponent::SetGunRecoilAlpha_Roll(const float NewRollRecoil)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponComponent", "SetGunRecoilAlpha_Roll");

	Params::WeaponComponent_SetGunRecoilAlpha_Roll Parms{};

	Parms.NewRollRecoil = NewRollRecoil;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.WeaponComponent.SetGunRecoilAlpha_Yaw
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewYawRecoil                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponComponent::SetGunRecoilAlpha_Yaw(const float NewYawRecoil)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponComponent", "SetGunRecoilAlpha_Yaw");

	Params::WeaponComponent_SetGunRecoilAlpha_Yaw Parms{};

	Parms.NewYawRecoil = NewYawRecoil;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.WeaponComponent.SetGunRecoilIsActive_Backward
// (Final, Native, Public, BlueprintCallable)

void UWeaponComponent::SetGunRecoilIsActive_Backward()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponComponent", "SetGunRecoilIsActive_Backward");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.WeaponComponent.SetStrivingGunRecoilAlpha_Pitch
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewStrivingPitchRecoil                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponComponent::SetStrivingGunRecoilAlpha_Pitch(const float NewStrivingPitchRecoil)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponComponent", "SetStrivingGunRecoilAlpha_Pitch");

	Params::WeaponComponent_SetStrivingGunRecoilAlpha_Pitch Parms{};

	Parms.NewStrivingPitchRecoil = NewStrivingPitchRecoil;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.WeaponComponent.SetWantsToAiming_server
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// bool                                    NewState                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponComponent::SetWantsToAiming_server(const bool NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponComponent", "SetWantsToAiming_server");

	Params::WeaponComponent_SetWantsToAiming_server Parms{};

	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.WeaponComponent.ToggleAiming_server
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)

void UWeaponComponent::ToggleAiming_server()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponComponent", "ToggleAiming_server");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function POLYGON.WeaponComponent.GetCurrentGun
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AItem_Gun_General*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AItem_Gun_General* UWeaponComponent::GetCurrentGun() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponComponent", "GetCurrentGun");

	Params::WeaponComponent_GetCurrentGun Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function POLYGON.WeaponComponent.GetGunRecoilAlpha_Backward
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UWeaponComponent::GetGunRecoilAlpha_Backward() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponComponent", "GetGunRecoilAlpha_Backward");

	Params::WeaponComponent_GetGunRecoilAlpha_Backward Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function POLYGON.WeaponComponent.GetGunRecoilAlpha_Pitch
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UWeaponComponent::GetGunRecoilAlpha_Pitch() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponComponent", "GetGunRecoilAlpha_Pitch");

	Params::WeaponComponent_GetGunRecoilAlpha_Pitch Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function POLYGON.WeaponComponent.GetGunRecoilAlpha_Roll
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UWeaponComponent::GetGunRecoilAlpha_Roll() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponComponent", "GetGunRecoilAlpha_Roll");

	Params::WeaponComponent_GetGunRecoilAlpha_Roll Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function POLYGON.WeaponComponent.GetGunRecoilAlpha_Yaw
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UWeaponComponent::GetGunRecoilAlpha_Yaw() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponComponent", "GetGunRecoilAlpha_Yaw");

	Params::WeaponComponent_GetGunRecoilAlpha_Yaw Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function POLYGON.WeaponComponent.GetIsShooting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWeaponComponent::GetIsShooting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponComponent", "GetIsShooting");

	Params::WeaponComponent_GetIsShooting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function POLYGON.WeaponComponent.IsAiming
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWeaponComponent::IsAiming() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponComponent", "IsAiming");

	Params::WeaponComponent_IsAiming Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function POLYGON.WeaponComponent.IsWantsToAiming
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWeaponComponent::IsWantsToAiming() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponComponent", "IsWantsToAiming");

	Params::WeaponComponent_IsWantsToAiming Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}

}

